# 요구사항 분석
n*m맵(0:이동o, 1:이동x)

- 시작 지점: (1, 1)
- 도착 지점: (N, M)

한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸

벽을 한 개 까지 부수고 이동하여도 된다.맵이 주어졌을 때, 최단 경로를 구해 내는 프로그램

최단경로는 맵에서 가장 적은 개수의 칸을 지나는 경로를 말하는데, 이때 시작하는 칸과 끝나는 칸도 포함

## 입력
N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 1,000)

다음 N개의 줄에 M개의 숫자로 맵이 주어진다.

## 출력(목표)
첫째 줄에 최단 거리(불가능할 때는 -1) 출력

# 왜 코드를 그렇게 짰는지
3차원 visited를 써야하나 안 써도 되나 모르겠어서 일단 `Coord`객체에 `isBroken` 상태를 넣어서 풀어봤다.

역시... 잘 되지는 않았다. 3차원 visited를 사용해서 해당 지점에 벽을 부수고 방문한 경우, 벽을 부수지 않고 방문한 경우를 따로 체크해준다.

현재 객체가 들고 있는 값에 따라 체크할 visited가 결정됨

# 핵심 로직
```java
private static int bfs(int startX, int startY) {
    Queue<Coord> queue = new ArrayDeque<>();
    boolean[][][] visited = new boolean[n][m][2];

    // 시작 지점 넣기
    queue.offer(new Coord(startX, startY, 1, false));
    visited[startX][startY][0] = true;

    while(!queue.isEmpty()) {
        Coord curr = queue.poll();

        if(curr.x == n-1 && curr.y == m-1) {
            return curr.cnt;
        }

        for(int dir =0; dir<4; dir++) {
            int nx = curr.x + dx[dir];
            int ny = curr.y + dy[dir];

            if(nx<0 || nx>=n || ny<0 || ny>=m) continue;

            if(map[nx][ny]==1) {
                if(!curr.isBroken && !visited[nx][ny][1]) {
                    queue.offer(new Coord(nx, ny, curr.cnt+1, true));
                    visited[nx][ny][1] = true;
                }
            }else{
                int broken = curr.isBroken ? 1 : 0;
                if(!visited[nx][ny][broken]) {
                    queue.offer(new Coord(nx, ny, curr.cnt+1, curr.isBroken));						visited[nx][ny][broken]  = true;

                }
            }
        }
    }


    return -1;
}
```

# 제출
![img.png](Attached/boj_2206.png)
