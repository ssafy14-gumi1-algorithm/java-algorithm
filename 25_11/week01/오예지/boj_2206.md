# 요구사항 분석
(1, 1)에서 (N, M) 까지 이동하려고 하는데 0은 이동 가능 한 곳, 1은 벽이 존재하는 곳
벽을 한 개 까지 부수고 이동할 수 있음
이 때 최단 경로를 구해내는 프로그램을 작성

## 입력
첫째 줄에 N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 1,000)이 주어진다.\
다음 N개의 줄에 M개의 숫자로 맵이 주어진다.\
(1, 1)과 (N, M)은 항상 0이라고 가정하자.

## 출력(목표)
첫째 줄에 최단 거리를 출력한다. 불가능할 때는 -1을 출력한다.

# 왜 코드를 그렇게 짰는지
- 말숭이 문제가 생각나서 3차원 visited를 사용했음!
  - 벽을 부숴서 이동한 경우와 벽을 부수지 않고 이동한 경우도 visited에 포함시켜줌
- 최단 경로를 찾는 문제여서 bfs 사용
  - 벽을 부수고 지나가는 경우와 벽을 부수지 않고 pass 하는 두 가지 경우를 큐에 넣는 형식으로 코드를 작성

# 핵심 로직
```declarative
public static int bfs(int si, int sj) {
    Queue<Coord> q = new LinkedList<>();
    visited[si][sj][0] = 1;
    q.add(new Coord(si, sj, 0));

    while(!q.isEmpty()) {
        Coord temp = q.poll();
        int ti = temp.i;
        int tj = temp.j;
        int cnt = temp.c;

        // 종료 조건
        if (ti==N && tj==M) {
            return visited[ti][tj][cnt];
        }

        for(int d=0; d<4; d++) {
            int ni = ti + di[d];
            int nj = tj + dj[d];
            int nCnt = cnt;

            // 1. 일단 범위에 해당하는지 먼저 확인
            if(ni<1 || ni>N || nj<1 || nj>M) continue;

            // 2. 방문했는지 확인
            if (visited[ni][nj][nCnt] != 0) continue;

            // 3. 해당 칸이 벽이 아니라면 그냥 지나감
            if (field[ni][nj]==0) {
                visited[ni][nj][nCnt] = visited[ti][tj][cnt]+1;
                q.add(new Coord(ni, nj, nCnt));
            }

            if (field[ni][nj]==1) {
                // 4. 벽을 부술 수 있는지? -> nCnt가 0인 경우에만 벽을 부시고 지나갈 수 있음
                if (nCnt==0) {
                    nCnt++;
                    visited[ni][nj][nCnt]=visited[ti][tj][cnt]+1;
                    q.add(new Coord(ni, nj, nCnt));
                }
                // 4-1. 벽인데 부실수 없다면 지나갈 수 없음
                else continue;
            }
        }
    }
    return -1;
}
```
