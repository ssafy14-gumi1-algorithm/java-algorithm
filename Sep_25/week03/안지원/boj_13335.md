# 요구사항 분석
트럭

- 강을 가로지르는 하나의 차선으로 된 다리가 하나 있다.
- 이 다리를 n 개의 트럭이 건너가려고 한다.
- 트럭의 순서는 바꿀 수 없으며, 트럭의 무게는 서로 같지 않을 수 있다.
- 다리 위에는 단지 [w 대의 트럭만 동시에 올라갈 수 있다.]
- 다리의 길이는 w 단위길이(unit distance)이며,
- 각 트럭들은 하나의 단위시간(unit time)에 하나의 단위길이만큼만 이동할 수 있다고 가정한다.
- [동시에 다리 위에 올라가 있는 트럭들의 무게의 합은 다리의 최대하중인 L보다 작거나 같아야 한다. ]
- 참고로, 다리 위에 완전히 올라가지 못한 트럭의 무게는 다리 위의 트럭들의 무게의 합을 계산할 때 포함하지 않는다고 가정한다.

- 다리의 길이와 다리의 최대하중, 그리고 다리를 건너려는 트럭들의 무게가 순서대로 주어졌을 때,
- 모든 트럭이 다리를 건너는 최단시간을 구하는 프로그램을 작성하라.

## 입력
- 입력 데이터는 표준입력을 사용한다. 입력은 두 줄로 이루어진다.
- 입력의 첫 번째 줄에는 세 개의 정수 n (1 ≤ n ≤ 1,000) , w (1 ≤ w ≤ 100) and L (10 ≤ L ≤ 1,000)이 주어지는데,
- n은 다리를 건너는 트럭의 수, w는 다리의 길이, 그리고 L은 다리의 최대하중을 나타낸다.
- 입력의 두 번째 줄에는 n개의 정수 a1, a2, ⋯ , an (1 ≤ ai ≤ 10)가 주어지는데, ai는 i번째 트럭의 무게를 나타낸다.

## 출력(목표)
- 출력은 표준출력을 사용한다. 모든 트럭들이 다리를 건너는 최단시간을 출력하라.

# 왜 코드를 그렇게 짰는지
- 첨에 문제 보고 그리디로 간지나게 풀 수 있겠는데? 생각하고 1시간 동안 그리디로 풀어보려고 했는데 안됐음
- 그래서 질문 계시판 제목만 좀 훑어봤는데, 그리디로 못 푼대...
- deque 자료구조로 진짜 이동하는 로직을 구현해야 할 듯
- deque자료형 있으니깐 앞뒤로 배열을 빼주면 O(1)로 트럭들이 이동하는걸 구현할 수 있으니

# 핵심 로직
## deque로 다리 위에 트럭 직접 구현하기
- deque 자료형을 쓰면 앞 뒤로 데이터를 빼는데 O(1)로 뺄 수 있음
- 기존 배열은 앞에서 자료를 빼면 뒤에 있는 데이터들이 앞으로 땡겨지면서 O(N)이 발생하는데 deque는 괜찮음
- 현재 다리에 다음 트럭이 추가되어도 무게를 버틸 수 있으면 트럭을 추가하고, 무게를 못 버티면 그냥 이동했다는 표시인 0을 추가함
- 이어서 다리에 맨 앞의 값을 빼준다 => 이러면 다리에 있는 트럭들이 전부 1칸씩 움직인게 된다.
- 맨 앞에 뺀 값을 현재 다리의 무게에서 빼준다(트럭이 빠져나왔으면 트럭의 무게가 빠질거고, 트럭이 아니면 0이 빠질테니 무게에 빼줘도 상관x)
- 다리에 끝에 값을 추가하는 로직은 더 이상 도로에 들어갈 트럭이 없을때 까지 진행함
- 더 이상 도로에 들어갈 트럭이 없으면, 도로 배열이 다 빠질때 까지 앞에서 빼는 작업만 반복해주면 끝
```java
// 현재 다리에 있는 트럭 총 무게
now_weight = 0;
// 총 시간(결과)
time = 0;
// 모든 트럭이 도로를 빠져나갈때 까지 반복
while(bridge.size() > 0){
    time++;
    // 맨 앞에 빼주기
    int out_weight = bridge.pollFirst();
    // 무게에서 빼주기(트럭이면 무게가 빠져나갈거임)
    now_weight -= out_weight;

    // 남아있는 트럭이 있으면
    if(trucks.size() > 0){
        // 현재 다리에 있는 트럭들이 L을 초과하지 않으면 트럭 추가
        if(now_weight + trucks.peekFirst() <= L){
            // 다음으로 출발할 트럭 빼기
            int append_truck = trucks.pollFirst();
            // 트럭 담아주기
            bridge.addLast(append_truck);
            // 다리 무게 추가
            now_weight += append_truck;
        // L을 초과했으면 그냥 움직이기
        } else {
            // 그냥 이동 처리
            bridge.addLast(0);
        }
    }
}
```
