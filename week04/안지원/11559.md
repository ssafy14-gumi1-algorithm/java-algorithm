# 요구사항 분석
뿌요뿌요

- 뿌요뿌요의 룰은 다음과 같다.

- 필드에 여러 가지 색깔의 뿌요를 놓는다.
- 뿌요는 중력의 영향을 받아 아래에 바닥이나 다른 뿌요가 나올 때까지 아래로 떨어진다.
- 뿌요를 놓고 난 후, 같은 색 뿌요가 4개 이상 상하좌우로 연결되어 있으면 연결된 같은 색 뿌요들이 한꺼번에 없어진다. 이때 1연쇄가 시작된다.
- 뿌요들이 없어지고 나서 위에 다른 뿌요들이 있다면, 역시 중력의 영향을 받아 차례대로 아래로 떨어지게 된다.
- 아래로 떨어지고 나서 다시 같은 색의 뿌요들이 4개 이상 모이게 되면 또 터지게 되는데, 터진 후 뿌요들이 내려오고 다시 터짐을 반복할 때마다 1연쇄씩 늘어난다.
- 터질 수 있는 뿌요가 여러 그룹이 있다면 동시에 터져야 하고 여러 그룹이 터지더라도 한번의 연쇄가 추가된다.

- 상대방의 필드가 주어졌을 때, 연쇄가 몇 번 연속으로 일어날지 계산하기

## 입력
- 총 12개의 줄에 필드의 정보가 주어지며, 각 줄에는 6개의 문자가 있다.
- 이때 .은 빈공간이고 .이 아닌것은 각각의 색깔의 뿌요를 나타낸다.
- R은 빨강, G는 초록, B는 파랑, P는 보라, Y는 노랑이다.
- 입력으로 주어지는 필드는 뿌요들이 전부 아래로 떨어진 뒤의 상태이다. 즉, 뿌요 아래에 빈 칸이 있는 경우는 없다.

## 출력(목표)
- 현재 주어진 상황에서 몇연쇄가 되는지 출력한다. 하나도 터지지 않는다면 0을 출력한다.

# 왜 코드를 그렇게 작성했는지
- 주요 로직은 2개임
- 1. 현재 블럭이 같은색으로 4개 이상으로 연결되어있는 블럭일 경우 전부 파괴하는(.으로 바꾸는) 로직
- 2. 파괴된 블럭 위에 있는 블럭을 중력으로 아래로 내리는 로직
- 2개의 로직을 만들고 1번 로직을 실행했을때 블럭이 아무것도 파괴되지 않은 경우 까지 반복문을 실행하고, 반복문이 총 몇 번 실행되었는지 출력하면 됨
- 1번 로직은 BFS로 구현하고, 블럭을 파괴하기 위한 추가 좌표정보 변수를 하나 만들어야 하는게 포인트
- 2번 로직은 열을 기준으로 맨 아래에서 위로 올라가는 반복문을 실행해야 함
- 그리고 투 포인터를 이용해 가장 첫 번째 .의 위치를 저장하고, 그 위에 블럭을 발견할 시 블럭과 가장 첫 번째 .의 위치를 바꿔주고 .의 좌표를 위로 올려주는게 포인트

# 핵심 로직
## 1. 현재 블럭이 같은색으로 4개 이상으로 연결되어있는 블럭일 경우 전부 파괴하는(.으로 바꾸는) 로직
- BFS로 접근하는게 편함
- BFS보다 상위 스코프에 존재하는 visited배열을 사용(블럭 부수기 + 블럭 중력 적용하기 싸이클 1번 마다 visited는 초기화 됨)
- BFS 안에선 동일한 색깔의 블럭의 좌표를 담는 comp 배열 추가 생성(이 comp의 길이가 4개 이상이면 해당 좌표 블럭들을 전부 파괴(.으로 바꿈)해주는 용도로 사용함)
- BFS를 돌려서 현재 색깔 color와 같은 색을 가진 블럭이 있는지 상하좌우로 확인하고 발견할 때 마다 이동 + comp에 추가 해줌
- BFS를 다 돌리고 받은 comp배열의 길이가 4개 이상이라면 파괴 진행, 아니면 뿌요뿌요 중단 후 결과값 반환하면 됨
```java
// 동일 색 연결 컴포넌트 BFS로 모으기
static List<int[]> bfs(int sx, int sy, char color) {
    // 큐
    ArrayDeque<int[]> queue = new ArrayDeque<>();
    // 같은색 블럭 4개 이상 연결될 시 블럭 파괴용 좌표
    List<int[]> comp = new ArrayList<>();
    // 처음 방문여부 체크
    visited[sy][sx] = true;
    // 큐 초기화
    queue.add(new int[]{sx, sy});

    while (!queue.isEmpty()) {
        // 큐에서 현재좌표 뽑아내기
        int[] cur = queue.poll();
        // x, y좌표 뽑기
        int x = cur[0], y = cur[1];
        // 현재 좌표 블럭 파괴용 좌표에 담기
        comp.add(cur);

        // 4방향으로 탐색 시작
        for (int dir = 0; dir < 4; dir++) {
            int nx = x + dx[dir];
            int ny = y + dy[dir];
            // 현재 좌표가 틀을 벗어나지 않고, 다음 지역이 같은색에 방문하지 않은 지역이면 이동하기
            if (0 <= nx && nx < W && 0 <= ny && ny < H
                    && !visited[ny][nx]
                    && board[ny][nx] == color) {
                // 다음 지역 방문체크
                visited[ny][nx] = true;
                // 큐에 다음지역 추가하기
                queue.add(new int[]{nx, ny});
            }
        }
    }
    // 파괴될 블럭 좌표 배열 출력
    return comp;
}
```
## 2. 파괴된 블럭 위에 있는 블럭을 중력으로 아래로 내리는 로직
- 1번 로직으로 파괴된 블럭들을 중력으로 내려줘야 함
- 열 마다 맨 아래에서 위로 올라가는 반복문을 실행(위에서 아래로 내려가는건 로직이 복잡해짐)
- 맨 처음 .의 좌표와, 그 위에 나오는 블럭의 좌표 두개를 활용한 투포인터 방식으로 교환 로직 실행
- 올라가다 맨 처음 발견되는 .의 좌표를 기록하고, 그 위에 블럭이 존재한다면 .과 블럭을 교환해주고, .의 좌표를 1칸 올려줌(밑에서 위로 올라가니 -1 해줘야 함)
- 그렇게 모든 열을 투포인터로 교환하면 끝
```java
// 각 열마다 아래로 당기기(두 포인터 방식)
static void applyGravity() {
    for (int x = 0; x < W; x++) {
        int write = H - 1; // 채워넣을 위치(바닥부터 위로)
        // 현재 열의 바닥행 부터 맨 위로 올라오는 반복문 실행
        for (int y = H - 1; y >= 0; y--) {
            // 현재 위치에 블럭이 존재하면
            if (board[y][x] != '.') {
                // 블럭 저장
                char c = board[y][x];
                // 현재 블럭을 .으로 교체
                board[y][x] = '.';
                // 채워넣을 위치에 블럭 넣기
                board[write][x] = c;
                // 채워넣을 위치 상승
                write--;
            }
        }
    }
}
```

