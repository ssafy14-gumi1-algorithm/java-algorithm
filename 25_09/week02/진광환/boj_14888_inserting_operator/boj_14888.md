아래는 **BOJ 14888 연산자 끼워넣기** 문제 풀이 리드미 예시입니다. 요구사항(입출력, 목표, 제약 등), 코드 작성 이유, 함수 설명, 에러 및 배운 점까지 모두 포함하여 서술하였습니다:[1][2][3]

***

## 요구사항 분석

- **입력**
    - 첫째 줄: N(2 ≤ N ≤ 11) – 수의 개수
    - 둘째 줄: N개의 수(1 이상 100 이하, 수열)
    - 셋째 줄: 덧셈, 뺄셈, 곱셈, 나눗셈 연산자 개수 (순서대로 0~4개, 합은 N-1)

- **출력**
    - 1행: 연산자를 모두 사용해 얻을 수 있는 수식 결과의 **최댓값**
    - 2행: 연산자를 모두 사용해 얻을 수 있는 수식 결과의 **최솟값**

- **문제 목표**
    - 주어진 순서의 숫자 사이에 연산자를 모두 한 번씩 배분(중복X, 순열로 완전탐색)
    - 연산 우선순위는 무시하고, **왼쪽부터 순서대로 계산**
    - 나눗셈에서 음수인 경우: “양수로 바꾼 뒤 몫을 취하고 그 몫은 음수로 바꾼다”
    - 결과값의 범위는 ±10억 이내로 충분히 int로 처리 가능

- **시간복잡도**
    - 수가 N개일 때 2번째 수부터 재귀를 돌리므로 재귀 깊이는 N-1 유형 4개 N은 최대 11이다.→ 경우의 수는 최대 4^10개이다.
    - 100만번 정도의 연산이 가능하고 제한시간이 2초, 자바는 1초에 1억번 연산가능하므로 재귀함수로 계산 쌉가능
    - 또한 하나의 재귀로 최대, 최소를 둘다 구해야 하는 문제이므로 가지치기를 하지 않고 반드시 모든 연산을 다 해야 한다.
***

## 풀이 및 작성 이유

- 완전탐색/백트래킹이 적합
    - N이 매우 작아 모든 연산자 조합을 시도해 볼 수 있음[2][1]
    - 각 깊이마다 사용 가능한 연산자가 있으면 순회하며 재귀 호출(상태 백트래킹)
- 연산자 순서, 숫자 순서를 바꿀 수 없으니, **연산자 개수 배열(operators[]: +, -, ×, ÷ 카운트)**을 이용해 수동으로 뺄셈, 곱셈, 나눗셈 시도
- 결과를 글로벌 변수(min_val, max_val)에 갱신(매 호출 마다 비교)
- 음수 나눗셈은 문제 조건에 맞게 처리

***

## 함수 설명

- **recur(int idx, int curresult):**
    - idx: 현재까지 사용한 수의 개수(1이면 두 번째 수로 진입 중)
    - curresult: 누적 결과 값
    - operators: 남은 각 연산자의 개수[4]
    - 재귀 루프(4가지 연산자), 남은 연산자가 있으면 사용
    - 목적지 도달(idx==N)이면 결과 전역 변수 갱신

***

## Error Report

- **초기화 문제**: min_val / max_val을 초기화하지 않거나, 값을 잘못 줘서 틀릴 수 있음
- **음수 나눗셈 연산**: 문제 조건(음수 몫 부호) 구현 미흡하면 오답
- **오버플로우 걱정**: 없음(값 범위 내)
- **가짓수 가지치기**: 최댓값·최솟값 모두 필요하므로 중간 가지치기 불가

***

## 배운 점/개선점

- 문제를 풀고 나서 시간복잡도를 계산하는 방법을 ai에게 다시 물어보고 계산해보았다.
- 이를 통해서 시간복잡도를 어떻게 계산하는지, 자바의 1초 연산량을 배울 수 있었다.
- 또한 이 문제와 같이 재귀하나로 최대, 최소를 모두 구해야 하는 문제는 반드시 모든 계산을 다 해야 해서 시간이 널널하게 주어짐을 알 수 있었다.
- 다음에는 문제를 풀기 전에 시간복잡도를 계산해봐야겠다.

***

