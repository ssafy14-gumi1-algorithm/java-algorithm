# 요구사항 분석
가로와 세로의 중간 부분을 잘랐을 때 잘라진 종이가 모두 하얀색 또는 파란색으로 칠해져 있거나, 하나의 정사각형 칸이 되어 더 이상 자를 수 없으면, 색종이 하나로 카운팅한다.
규칙에 따라 잘랐을 때, 최종적으로 만들어지는 하얀색 종이와 파란색 종이의 개수를 출력

## 입력
첫째 줄에는 전체 종이의 한 변의 길이 N이 주어져 있다. N은 2, 4, 8, 16, 32, 64, 128 중 하나이다.\
색종이의 각 가로줄의 정사각형칸들의 색이 윗줄부터 차례로 둘째 줄부터 마지막 줄까지 주어진다.\
하얀색으로 칠해진 칸은 0, 파란색으로 칠해진 칸은 1로 주어지며, 각 숫자 사이에는 빈칸이 하나씩 있다.

## 출력(목표)
첫째 줄에는 잘라진 햐얀색 색종이의 개수를 출력하고, 둘째 줄에는 파란색 색종이의 개수를 출력한다.

# 왜 코드를 그렇게 짰는지
1. 일단은 분할정복으로 푸는 문제
2. 한번 나누고 크기가 1인지 확인함
3. 크기가 1이 아니라면 해당 칸의 모든 숫자가 같은지 확인
3. 같은 숫자라면 해당 칸의 맞는 색의 카운트를 올림
4. 아니라면 한번 더 4칸으로 분할

# 핵심 로직

```declarative
public static void recur(int x1, int y1, int x2, int y2) {
    if (x1==x2 && x2==y2) {
        resultCnt[field[x1][y1]]++;
    }

    int result = check(x1, y1, x2, y2);

    int midX = (x1+x2)/2;
    int midY = (y1+y2)/2;

    if (result==2) {
        recur(x1, y1, midX, midY);
        recur(x1, midY, midX, y2);
        recur(midX, y1, x2, midY);
        recur(midX, midY, x2, y2);
    }else {
        resultCnt[result]++;
    }
}
```

```declarative
public static int check(int x1, int y1, int x2, int y2) {
    int temp = field[x1][y1];
    for (int i=x1; i<x2; i++) {
        for(int j=y1; j<y2; j++) {
            if (field[i][j] != temp) {
                return 2;
            }
        }
    }

    return temp;
}
```
