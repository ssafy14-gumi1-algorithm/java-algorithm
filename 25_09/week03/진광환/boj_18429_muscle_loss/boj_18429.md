## 요구사항 분석

- **입력**
    - N (1 ≤ N ≤ 8): 운동 키트 개수
    - K (1 ≤ K ≤ 50): 하루 중량 감소량
    - N개의 운동 키트 중량 배열 (각 운동 키트 무게 ≥ K)

- **출력**
    - 운동 기간 동안 매일 한 개의 키트를 사용하면서 중량이 항상 500 이상이 되도록 키트를 나열하는 경우의 수

- **문제 목표**
    - 중량 500에서 시작해, 매일 중량이 감소량 K만큼 떨어지고 운동 키트 중량 만큼 늘어나는 순서에서
    - 중량이 하루라도 500 미만으로 떨어지지 않는 모든 가능한 키트 순열의 개수를 출력

- **제약사항**
    - 운동 키트 순서 바꾸기 가능 (모든 순열 고려)
    - 중량은 매일 중량으로 계산되며 중량이 500 미만이 되면 해당 순서는 실패 처리

- **시간 복잡도**
    - N 최대 8이므로 완전탐색(순열 생성, O(N!) 충분히 가능

***

## 풀이 및 작성 이유

- 아이디어:
    - 총 N개의 운동 키트를 중량 감소량 K 처리 후 중량 증강량으로 저장
    - 재귀(백트래킹)로 모든 순열 탐색 (`perm` 함수)
    - 순열을 구한 다음 path배열의 앞에서부터 하나씩 숫자를 더해가면서 0미만이 되면 리텅

- 중량을 매 바로 계산하는 대신 `kits[i] = 운동 키트 무게 - K`로 조절하여 누적 계산에서 편리함

***

## 함수 설명

- **perm(int idx):**
    - idx: 현재 순열의 위치 (몇 번째 키트를 사용했는지)
    - 길이 N의 순열을 완성할 때까지 백트래킹
    - 중복 사용 금지(used 배열)
    - 순열 완성 시까지 누적 중량이 500 미만이 되면 즉시 리턴
    - 성공적인 순열일 경우 answer 증가

***

## 배운 점/개선점

- N이 8정도로 낮은 값인 걸 봤을 때 순열이라는 것을 판단할 수 있었음
- 다음 번에 풀 때는 재귀 매개변수에 합을 넣어서 합이 500이하가 되면 재귀 호출을 중단하는 식으로 가지치기를 할 수 있을듯