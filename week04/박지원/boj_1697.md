# 요구사항 분석
수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다.

수빈이의 위치가 X일 때 , 1초 후에 X-1, X+1, 2*X의 위치로 이동할 수 있다.

수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성
## 입력
첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다((0 ≤ N ≤ 100,000)).
## 출력(목표)

# 왜 코드를 그렇게 짰는지
최단 거리를 찾는 문제. 수빈이가 이동할 수 있는 칸들을 노드로 보고 bfs를 해주면 됨.

최단거리 문제이므로 dfs보다 bfs가 적합하다.

이동에 걸리는 시간이 모두 1로 동일(가중치가 1이라고 볼 수 있음)
# 핵심 로직
수빈이의 위치와 해당 위치에 가기까지 걸린 시간을 담기 위한 class를 선언\
next 배열에 다음 위치(x+1, x-1, 2 * x)를 저장\
방향 배열 돌듯이 next배열 돌면서 해당 위치에 갈 수 있는지, 방문했는지 체크하면서 bfs
```java
public static class Subin {
    int pos;
    int time;

    public Subin(int curr, int time) {
        this.pos = curr;
        this.time = time;
    }
}

public static int bfs(int start) {
    Queue<Subin> queue = new ArrayDeque<>();
    boolean[] visited = new boolean[100_000 + 1];

    queue.offer(new Subin(start, 0));
    visited[start] = true;

    while (!queue.isEmpty()) {
        Subin curr = queue.poll();

        // 동생을 찾으면 time 반환
        if (curr.pos == k) {
            return curr.time;
        }

        int[] nexts = { curr.pos + 1, curr.pos - 1, curr.pos * 2 };

        for (int next : nexts) {
            // 범위 밖
            if (next < 0 || next > 100_000)
                continue;
            // 이미 방문
            if (visited[next])
                continue;

            queue.offer(new Subin(next, curr.time + 1));
            visited[next] = true;
        }

    }

    return -1;
}
```