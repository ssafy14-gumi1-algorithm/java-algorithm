# 요구사항 분석
입력으로 주어진 방향대로 종수가 움직였을 때, 보드의 상태를 구하는 프로그램을 작성
중간에 게임에서 지게된 경우에는 몇 번째 움직임에서 죽는지를 구한다

## 입력
첫째 줄에 보드의 크기 R과 C가 주어진다. (1 ≤ R, C ≤ 100)

다음 R개 줄에는 C개의 문자가 주어지며, 보드의 상태이다. '.'는 빈 칸, 'R'은 미친 아두이노, 'I'는 종수의 위치를 나타낸다.

마지막 줄에는 길이가 100을 넘지않는 문자열이 주어지며, 종수가 움직이려고 하는 방향이다. 5는 그 자리에 그대로 있는 것을 나타내고, 나머지는 아래와 같은 방향을 나타낸다.

## 출력(목표)
중간에 게임이 끝나는 경우에는 "kraj X"를 출력한다. X는 종수가 게임이 끝나기 전 까지 이동한 횟수이다. 그 외의 경우에는 보드의 상태를 입력과 같은 형식으로 출력한다.

# 왜 코드를 그렇게 짰는지
1. 종수가 움직일 때
   - 종수가 움직이는 경우는 정해져 있기 때문에 해당 위치에 미친 아두이노가 있는지 확인하고 미친 아두이노가 있는 경우에는 flag를 변경해서 종수의 아두이노가 죽었음을 확인함

2. 미친 아두이노가 움직일 때
   - 미친 아두이노는 모든 방향을 확인해서 종수와의 거리가 가장 짧은 방향으로 이동했음
   - 미친 아두이노가 겹치는 경우에는 해당 위치에 있는 모든 아두이노가 파괴되기 때문에, 움직이고 난 후에 해당 위치에 미친 아두이노가 몇 개씩 있는지 카운트가하고 카운트가 2인 경우에는 새로 필드를 정의할 때 제외해줌
   - 종수의 아두이노와 겹치는 경우에는 게임이 끝나므로 flag를 변경해줌

# 핵심 로직
1. index번째 미친 아두이노 이동
```declarative
public static void moveMad(int index){
    Coord cur = mad.get(index);
    int ri = cur.i;
    int rj = cur.j;

    int minDis = Integer.MAX_VALUE;
    int bestDir = 5; // 일단 제자리(5)로 초기화

    // 1~9 방향 모두 보되, 범위 밖은 스킵
    for (int d = 1; d <= 9; d++){
        int ni = ri + di[d];
        int nj = rj + dj[d];

        if (ni < 0 || ni >= R || nj < 0 || nj >= C) continue;

        int dt = distance(jong_i, jong_j, ni, nj);

        if (dt < minDis){
            minDis = dt;
            bestDir = d;
        }
    }

    int ni = ri + di[bestDir];
    int nj = rj + dj[bestDir];

    // 이동한 위치가 종수 위치면 바로 사망 처리
    if (ni == jong_i && nj == jong_j){
        flag = true;
    }

    mad.set(index, new Coord(ni, nj));
}
```

2. 종수의 아두이노와 미친 아두이노 둘 다 이동후의 필드를 다시 세팅함
```declarative
public static void set_field(){
    // 모든 칸 초기화
    for (int i=0; i<R; i++){
        Arrays.fill(field[i], '.');
    }

    // 종수 위치 찍기
    field[jong_i][jong_j] = 'I';

    // 미친 아두이노들 먼저 찍으면서, 서로 겹치는지 확인
    int[][] count = new int[R][C];
    for (Coord cor : mad){
        count[cor.i][cor.j]++;
    }

    ArrayList<Coord> nextMad = new ArrayList<>();

    for (Coord cor : mad){
        int r = cor.i;
        int c = cor.j;

        // 둘 이상 모이면 폭발 → 안 남김
        if (count[r][c] >= 2) continue;

        // 살아남은 R만 보드에 표시
        if (field[r][c] == 'I') {

        } else {
            field[r][c] = 'R';
        }
        nextMad.add(new Coord(r, c));
    }

    mad = nextMad;
}
```



