# 요구사항 분석
### 틱택토

- 틱택토 게임은 두 명의 사람이 번갈아가며 말을 놓는 게임이다.
- 게임판은 3×3 격자판이며, 처음에는 비어 있다.
- 두 사람은 각각 X 또는 O 말을 번갈아가며 놓는데, 반드시 첫 번째 사람이 X를 놓고 두 번째 사람이 O를 놓는다.
- 어느 때든지 한 사람의 말이 가로, 세로, 대각선 방향으로 3칸을 잇는 데 성공하면 게임은 즉시 끝난다.
- 게임판이 가득 차도 게임은 끝난다.

- 게임판의 상태가 주어지면, 그 상태가 틱택토 게임에서 발생할 수 있는 최종 상태인지를 판별하시오.
## 입력
- 입력은 여러 개의 테스트 케이스로 이루어져 있다.
- 각 줄은 9개의 문자를 포함하며, 'X', 'O', '.' 중 하나이다.
- '.'은 빈칸을 의미하며, 9개의 문자는 게임판에서 제일 윗 줄 왼쪽부터의 순서이다.
- 입력의 마지막에는 문자열 "end"가 주어진다.

## 출력(목표)
- 각 테스트 케이스마다 한 줄에 정답을 출력한다.
- 가능할 경우 "valid", 불가능할 경우 "invalid"를 출력한다.

# 왜 코드를 그렇게 짰는지
- valid가 되는 경우를 생각해보자.
- O는 후공, X는 선공임

### O가 이기는 경우
1. X와 O 숫자가 동일, O만 3줄이 완성됨
### X가 이기는 경우
1. X가 O보다 1개 더 많음, X만 3줄이 완성됨
### 아직 진행중인 경우
1. X가 O보다 1개 더 많거나 같음, 둘 다 3줄이 완성되지 않음
- 이거 외엔 전부 invalid 처리 해주면 되지 않을까?

# 핵심 로직
## X, O의 갯수에 따라 로직 분기
- X가 선공, O가 후공이라 정상적인 경우는 X와 O가 같거나, X가 O 보다 1 더 큰 경우 말곤 없음
- 이거부터 틀리면 바로 invalid를 반환해야함
``` java
// 1. 갯수 세기
for (int i = 0; i < 9; i++) {
    char t = t_list[i];
    if (t == 'X') {
        X += 1;
        t_arr[i / 3][i % 3] = 'X';
    } else if (t == 'O') {
        O += 1;
        t_arr[i / 3][i % 3] = 'O';
    }
}

// O가 더 많으면 잘못된거
if (O > X) {
    sb.append("invalid").append('\n');
    continue;
}
```

## 2. O, X 빙고 만들어졌는지 확인하는 dfs
- 현재 위치를 기준으로 O나 X가 있는 경우, 방향을 고정시켜 쭉 재귀시키기
- 같은 문자가 재귀를 3번 반복 성공했으면 빙고가 완성된거니 빙고를 만들었다는 True를 반환시키게 만듬
- O와 X가 일단 갯수상으론 결과가 나올 수 있는 경우엔 이 dfs를 돌려서 O, X의 빙고 여부를 판단하면 됨

```java
// O, X 빙고 있는지 확인하는 함수
static boolean[] find_bingo() {
    boolean O_bingo = false;
    boolean X_bingo = false;

    for (int y = 0; y < 3; y++) {
        for (int x = 0; x < 3; x++) {
            if (t_arr[y][x] == 'O') {
                char targ = 'O';
                for (int dir = 0; dir < 8; dir++) {
                    if (!O_bingo) {
                        O_bingo = dfs(x, y, targ, dir, 1);
                    }
                }
            } else if (t_arr[y][x] == 'X') {
                char targ = 'X';
                for (int dir = 0; dir < 8; dir++) {
                    if (!X_bingo) {
                        X_bingo = dfs(x, y, targ, dir, 1);
                    }
                }
            }
        }
    }

    return new boolean[] { O_bingo, X_bingo };
}
```
## 3. 갯수에 따라 빙고 여부 판단
1. O == X
  - O가 마지막으로 공격한 상태
    - O는 빙고를 달성하고, X는 빙고를 달성하지 못함(valid)
2. O < X
   - X가 마지막으로 공격한 상태
     - X는 빙고를 달성하거, O는 빙고를 달성하지 못함(valid)
     - 둘 다 빙고 달성 못했지만 판을 전부 다 채움(valid)
3. 나머지는 다 invalid
```java
// 2. 갯수에 따른 X, O 빙고 여부 판단
// 마지막 턴이 O인 경우
if (O == X) {
    // O가 빙고를 만들었고, X는 빙고를 만들지 못했는지 확인
    boolean[] res = find_bingo();
    boolean O_bingo = res[0];
    boolean X_bingo = res[1];

    if (O_bingo && !X_bingo) {
        sb.append("valid").append('\n');
        continue;
    } else {
        sb.append("invalid").append('\n');
        continue;
    }
}
// 마지막 턴이 X인 경우
else if (O + 1 == X) {
    // X가 빙고를 만들었고, O는 빙고를 만들지 못했는지 확인
    boolean[] res = find_bingo();
    boolean O_bingo = res[0];
    boolean X_bingo = res[1];

    if (X_bingo && !O_bingo) {
        sb.append("valid").append('\n');
        continue;
    }
    // 무승부로 마무리 된 경우 추가
    else if (!O_bingo && !X_bingo && O + X == 9) {
        sb.append("valid").append('\n');
        continue;
    } else {
        sb.append("invalid").append('\n');
        continue;
    }
}
// 나머진 전부 invalid
else {
    sb.append("invalid").append('\n');
    continue;
}
```



