# 요구사항 분석
파리 킬러 스프레이를 한 번만 뿌려 최대한 많은 파리를 잡으려고 한다.\
스프레이의 노즐이 + 형태로 되어있어, 스프레이는 + 혹은 x 형태로 분사된다.\
스프레이를 M의 세기로 분사하면 노즐의 중심이 향한 칸부터 각 방향으로 M칸의 파리를 잡을 수 있다.\
뿌려진 일부가 영역을 벗어나도 상관없다.

## 입력
```
T: 테스트 케이스의 수
N: 배열 사이즈
M: 스프레이 세기
arr: N*N 사이즈
```
## 출력(목표)
m 세기로 스프레이를 분사해서 한 번에 잡을 수 있는 최대 파리 수 출력


# 왜 코드를 그렇게 작성했는지
문제에서 스프레이를 분사하는 방식은 +방향과 x방향 모두 구해야 함

델타좌표를 + 4분면, x 4분면으로 나눠야 +, x별로 죽인 파리 수를 알 수 있음

따라서 +랑 x 로직을 따로 분리해서 문제를 해결해야겠다고 판단함

파이썬에선 +랑 x 로직을 각각 함수로 분리해서 사용했는데 자바는 함수 안에 함수 선언하니 빨간줄이 생겨서 일단 for문으로 한번에 로직 돌림..

# 핵심 로직
## +, x 델타 분리
방향 별로 잡은 파리수를 구하는 문제기 때문에 델타를 분리하여 제작
```java
int[] dx = {1, 0, -1, 0};   // 우 하 좌 상 (직선 방향)
int[] dy = {0, 1, 0, -1};

int[] mx = {1, 1, -1, -1};  // 우하 좌하 좌상 우상 (대각선 방향)
int[] my = {1, -1, -1, 1};
```

## 좌표가 바깥으로 벗어나지 않도록 if문 설정 잘하기
```
int total1 = area[y][x];
for (int i = 0; i < 4; i++) {
    int sX = x;
    int sY = y;
    for (int j = 1; j < m; j++) {
        sX += dx[i];
        sY += dy[i];
        if (sX >= 0 && sY >= 0 && sX < n && sY < n) {
            total1 += area[sY][sX];
        }
    }
}
```
+, x 방향으로 순회하면서 M의 세기(길이)만큼 스프레이를 분사한다고 했음

프로그래밍 특성상 배열을 넘어서는 좌표를 호출하려 하면 out of range 오류가 발생하게 됨

그래서 if문으로 현재 x, y좌표가(위의 코드에선 sX, sY) 0보다 큰지, n 미만인지를 우선적으로 구분하고 배열을 호출해야 함
```
if (sX >= 0 && sY >= 0 && sX < n && sY < n) {
    total1 += area[sY][sX];
}
```