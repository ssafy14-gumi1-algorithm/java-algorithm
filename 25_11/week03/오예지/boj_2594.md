# 요구사항 분석
두 사람이 만날 수 있는 시간 중 최대 시간을 구하면 됨

## 입력
첫째 줄에 놀이기구의 개수 N이 주어진다. 이어 N줄에 걸쳐 각 놀이기구의 운행시작 시각과 종료 시각이 빈 칸을 사이에 두고 주어진다. 시각은 시간단위 두 자리, 분 단위 두 자리로 구성되며 오후 1시는 13시, 오후 2시는 14시, ... , 오후 10시는 22시로 표현된다. N은 50이하의 자연수이다.

## 출력(목표)
첫째 줄에 세혁이와 근영이가 함께할 수 있는 가장 긴 시간을 분 단위로 출력한다. 만약 함께할 수 있는 시간이 없다면 첫째 줄에 0을 출력한다.

# 왜 코드를 그렇게 짰는지
1. 방문체크할 2차원 배열을 만들어줬음
2. 시작시간 앞으로 10분, 끝나는 시간 뒤로 10분을 포함해서 방문 체크를 해줌 
3. 모든 놀이기구의 방문체크를 끝내고, 가장 긴 쉬는 시간을 구해줌
=> 근데 이렇게 풀어도 되는 건지 모르겟음

# 핵심 로직
1. 앞으로 10분, 뒤로 10분 숫자 보정
```declarative
start_minute -= 10;
if (start_minute < 0){
    start_hour--;
    start_minute = 60+start_minute;
    if (start_hour<10){
        start_hour = 10;
        start_minute = 0;
    }
}

int end_hour = Integer.parseInt(end.substring(0, 2));
int end_minute = Integer.parseInt(end.substring(2));

end_minute += 10;
if (end_minute>=60){
    end_hour++;
    end_minute = (end_minute)%60;
    if (end_hour>=22){
        end_hour=22;
        end_minute=0;
    }
}
```

2. 놀이 기구 운행 시간을 방문 체크 해줌
```declarative
int sh = start_hour-10;
int sm = start_minute;

while(true){
    if (sh == (end_hour - 10) && sm == end_minute) break;  // 먼저 체크하고

    visited[sh][sm] = true;  // 그 다음에 찍기

    sm++;
    if (sm >= 60){
        sm = 0;
        sh++;
    }
}
```

3. 가장 긴 쉬는 시간을 찾아줌
```declarative
boolean flag = false;
int cnt = 0;
int maxCnt=0;
for(int k=0; k<12; k++){
    for(int j=0; j<60; j++) {
        if (visited[k][j] && flag){
            flag = false;
            maxCnt = Math.max(maxCnt, cnt);
            cnt = 0;
        }
        if (!visited[k][j]){
            flag = true;
            cnt++;
        }
    }
}

maxCnt = Math.max(maxCnt, cnt);
```
