# 요구사항 분석
- 벽 부수고 이동하기

- N×M의 행렬로 표현되는 맵이 있다.
- 맵에서 0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽이 있는 곳을 나타낸다.
- 당신은 (1, 1)에서 (N, M)의 위치까지 이동하려 하는데, 이때 최단 경로로 이동하려 한다.
- 최단경로는 맵에서 가장 적은 개수의 칸을 지나는 경로를 말하는데, 이때 시작하는 칸과 끝나는 칸도 포함해서 센다.

- 만약에 이동하는 도중에 한 개의 벽을 부수고 이동하는 것이 좀 더 경로가 짧아진다면, 벽을 한 개 까지 부수고 이동하여도 된다.

- 한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸이다.

- 맵이 주어졌을 때, 최단 경로를 구해 내는 프로그램을 작성하시오.
## 입력
- 첫째 줄에 N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 1,000)이 주어진다.
- 다음 N개의 줄에 M개의 숫자로 맵이 주어진다. (1, 1)과 (N, M)은 항상 0이라고 가정하자.
## 출력(목표)
- 첫째 줄에 최단 거리를 출력한다. 불가능할 때는 -1을 출력한다.
# 왜 코드를 그렇게 짰는지
- 늘 보던 맛인거 같은데
- 벽은 한개까지 부술 수 있음
- 최단경로니깐 BFS를 써야함
- 3차원 visited로 벽을 부순 경우까지 합쳐서 구하면 될듯
- 벽 부수기는 썼다, 안썼다로 나눌 수 있어서 오히려 편함
# 핵심 로직
## 벽 부수기 사용/미사용으로 3차원 visited 배열 만들기
- 일반적인 BFS 문제인데, 벽을 1번 부술 수 있음
- 최단 경로를 구할때 벽 부수기를 사용하지 않은 경우, 사용한 경우의 최단 루트도 감안해줘야함
- 벽 부쉈다, 안 부쉈다 => 길이 2짜리 True/False 배열 만들어주기
- 주의할점으로 0, 1 숫자로 표현하려고 하면 정수 자료형의 메모리 사용량이 꽤나 큼(-21억 ~ 21억까지 수용되니깐)
- 따라서 true/false 2개만 있는 boolean 자료형을 쓰는게 혹시나 메모리 초과가 뜨는걸 막을 수 있음
- 그래도 3차원 visited 문제 중에선 이게 최약체지 않을까(따로 문제를 꼬았거나 지문읽기 힘들거나 한건 없었어서)
```java
// 3차원 visited
visited = new boolean[N][M][2];
// 시작 지점 방문 표시: 파괴권 1개 보유 상태
visited[0][0][1] = true;
```
