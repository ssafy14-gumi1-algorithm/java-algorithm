# 요구사항 분석
바이러스

- 한 컴퓨터가 웜 바이러스에 걸리면 그 컴퓨터와 네트워크 상에서 연결되어 있는 모든 컴퓨터는 웜 바이러스에 걸리게 된다.
- 어느 날 1번 컴퓨터가 웜 바이러스에 걸렸다.
- 컴퓨터의 수와 네트워크 상에서 서로 연결되어 있는 정보가 주어질 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 출력하는 프로그램을 작성하시오.

## 입력
- 첫째줄엔 컴퓨터의 수 : 1 <= N <= 100
- 둘째줄엔 연결되어있는 컴퓨터 쌍의 수 M
- 그 다음줄 부터 컴퓨터의 수 만큼 컴퓨터 번호 쌍 A, B

## 출력(목표)
- 1번 컴퓨터가 웜 바이러스에 걸렸을 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 첫째 줄에 출력한다.

# 왜 코드를 그렇게 작성했는지
- 1번에서 바이러스가 전파될때 1번 컴퓨터와 인접한 컴퓨터들의 감염을 전부 찾아내는 문제
- 입력값으로 받는 경로들을 사용해 연결리스트를 만들고 완전탐색을 하면 됨
- visited 배열을 만들어 완전탐색을 돌리고, True로 바뀐 지역의 갯수를 구해서 1번 컴퓨터만 -1 해주면 답이 나옴
- 근데 BFS보단 DFS로도 풀이가 가능한 문제인거 같음

# 핵심 로직
## 1. 인접 리스트 만들기
- 인접 리스트 만들어서 1번을 기준으로 BFS를 돌리면 1번 컴퓨터랑 연결되어있지 않은 컴퓨터들은 카운트가 추가될 일이 없으니 인접리스트만 잘 만들면 끝
```java
public static void main(String[] args) throws IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int N = Integer.parseInt(br.readLine());   // 컴퓨터 수 (1..N)
    int M = Integer.parseInt(br.readLine());   // 연결 쌍 수

    // 제네릭 배열 대신 List<List<Integer>> 사용 → 경고 없음
    List<List<Integer>> adj = new ArrayList<>(N);
    for (int i = 0; i < N; i++) adj.add(new ArrayList<>());

    // 값 담기
    for (int i = 0; i < M; i++) {
        StringTokenizer st = new StringTokenizer(br.readLine());
        int a = Integer.parseInt(st.nextToken()) - 1; // 0-based
        int b = Integer.parseInt(st.nextToken()) - 1;
        adj.get(a).add(b);
        adj.get(b).add(a);
    }

    // 방문 배열 생성
    boolean[] visited = new boolean[N];
    // bfs 돌려서 감염된 컴퓨터값 담기(결과값(
    int infected = bfsCount(adj, visited, 0);

    // 1번 컴퓨터(시작점) 제외하고 결과 출력(max로 -1이 나올시 0 출력)
    System.out.println(Math.max(0, infected - 1));
}
```
## 2. BFS로 감염된 컴퓨터 갯수 구하기
- BFS 돌려서 1번과 연결되어있는 컴퓨터에 visited 체크 해주고 count 계속 늘려줌
- 더 탐색할 지역 없어서 while문 종료될 때 count값만 반환해주면 끝
```java
private static int bfsCount(List<List<Integer>> adj, boolean[] visited, int start) {
    // 큐 생성
    Queue<Integer> queue = new ArrayDeque<>();
    // 큐 초기화
    queue.add(start);
    // 현재 위치 체크
    visited[start] = true;

    // 바이러스 전파된 컴퓨터 카운트(결과값(
    int count = 0;
    while (!queue.isEmpty()) {
        // 현재값 뽑기
        int cur = queue.poll();
        // 바이러스 전파된 컴퓨터 추가
        count++;

        // 연결 리스트의 다음 연결지 반복문 실행
        for (int next : adj.get(cur)) {
            // 방문하지 않은 지역이면 체크 후 이동
            if (!visited[next]) {
                visited[next] = true;
                queue.add(next);
            }
        }
    }
    // 감염된 컴퓨터 출력
    return count;
}
```

