# 요구사항 분석
숫자를 외칠때마다 그동안 외친 수 중 중간값을 말하는 문제
외친 수의 개수가 짝수라면 그 중 작은 수를 말한다.

## 입력
첫째 줄에는 백준이가 외치는 정수의 개수 N이 주어진다.\
N은 1보다 크거나 같고, 100,000보다 작거나 같은 자연수이다.\
그 다음 N줄에 걸쳐서 백준이가 외치는 정수가 차례대로 주어진다.\
정수는 -10,000보다 크거나 같고, 10,000보다 작거나 같다.

## 출력(목표)
한 줄에 하나씩 N줄에 걸쳐 백준이의 동생이 말해야 하는 수를 순서대로 출력한다.

# 왜 코드를 그렇게 짰는지
1. 최대힙과 최소힙 두 가지를 사용함
2. 최대힙에는 우선순위가 높은 값보다 작은 값들을 넣어주고
3. 최소힙에는 우선순위가 높은 값보다 큰 값들을 넣어준다.
4. 최대힙과 최소힙에 들어있는 원소들의 개수가 같을 때, 최대힙의 peek 값이 중간값이고,
5. 각 힙의 원소들의 개수가 다르다면 원소의 개수가 더 많은 힙의 peek 값이 중간값이 된다.

# 핵심 로직
각 힙에 숫자를 넣어주는 과정
```declarative
public static void pqAdd(int num){
    // 최소 힙에는 큰 숫자들을 넣고, 최대 힙에는 작은 숫자들을 넣어야 peek를 봤을 때 중간값을 찾을 수 있음
    if (maxPq.isEmpty() || num < maxPq.peek()){
        maxPq.offer(num);
    }else{
        minPq.offer(num);
    }

    // 양쪽 개수 확인 - 2개 차이나는 경우에는 개수를 맞춰줌
    if (maxPq.size() > minPq.size() + 1){
        minPq.offer(maxPq.poll());
    } else if (minPq.size() > maxPq.size() + 1) {
        maxPq.offer(minPq.poll());
    }
}
```

두 힙의 사이즈를 비교해서 중간값을 찾아준다.
```declarative
public static int getMedian() {
    if (minPq.size() == maxPq.size()){
        return maxPq.peek();
    }else if (maxPq.size() > minPq.size()){
        return maxPq.peek();
    }else {
        return minPq.peek();
    }
}
```