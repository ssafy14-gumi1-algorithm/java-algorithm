# 요구사항 분석
원숭이는 K번 체스말처럼 움직이거나 인접한 칸으로 이동이 가능함
최소횟수로 H, W로 가는 횟수를 구해야함. 도착하지 못하는 경우 -1을 출력
격자판에서 0은 평지, 1은 장애물을 의미한다.

## 입력
첫째 줄에 정수 K가 주어진다. 둘째 줄에 격자판의 가로길이 W, 세로길이 H가 주어진다.\
그 다음 H줄에 걸쳐 W개의 숫자가 주어지는데, 0은 아무것도 없는 평지, 1은 장애물을 뜻한다.\
장애물이 있는 곳으로는 이동할 수 없다. 시작점과 도착점은 항상 평지이다.\
W와 H는 1이상 200이하의 자연수이고, K는 0이상 30이하의 정수이다.

## 출력(목표)
첫째 줄에 원숭이의 동작수의 최솟값을 출력한다.\
시작점에서 도착점까지 갈 수 없는 경우엔 -1을 출력한다.

# 왜 코드를 그렇게 짰는지
처음에는 2차원 visited를 사용했는데, 체스말처럼 이동할 수 있는 횟수가 정해져 있어서 불가능했음
그래서 K까지 포함한 3차원 배열을 사용함.
큐에는 현재위치, K, 이동 횟수를 넣어줌. 현재 위치가 [H-1, W-1] 이라면 bfs를 종료함
-> 가장 빠르게 도착지점에 도착했으므로 최소횟수로 이동했다고 생각할 수 있음 -> 이동에 가중치가 없으니까!

# 핵심 로직
인접한 칸을 이동하는 좌표 이동 배열과 체스말처럼 이동하는 좌표 이동 배열을 만들어줌
```declarative
    // 인접한 칸 이동을 위해서
    static int[] di = {0, 1, 0, -1};
    static int[] dj = {1, 0, -1, 0};

    // 체스말처럼 이동
    static int[] hi = {-1, 1, 2, 2, -1, 1, -2, -2};
    static int[] hj = {2, 2, -1, 1, -2, -2, -1, 1};
```

체스말로의 이동횟수는 최대 K번
그리고 한 곳을 기준으로 기본 이동 하는 경우와 체스말처럼 이동하는 경우를 모두 탐색해서 큐에 넣어줌
```declarative
public static int bfs(int si, int sj) {
    Queue<Coord> q = new LinkedList<>();
    q.offer(new Coord(si, sj, 0, 0));
    // 0으로 채워진 배열
    visited[si][sj][0] = true;

    while(!q.isEmpty()) {
        Coord cur = q.poll();
        int ti = cur.x;
        int tj = cur.y;
        int k = cur.k;
        int moves = cur.moves;

        if (ti == H-1 && tj == W-1) {
            return moves;
        }

        // 일단 기본 이동
        for (int d=0; d<4; d++) {
            int ni = ti + di[d];
            int nj = tj + dj[d];

            if (ni>=0 && ni<H && nj>=0 && nj<W) {
                // 장애물을 만남
                if (arr[ni][nj] == 1) continue;
                // 이미 방문한 곳 -> 이미 방문했던곳을 다시 방문하는 것은 최소 이동횟수가 되지 않음
                if (visited[ni][nj][k]) continue;

                visited[ni][nj][k] = true;
                q.offer(new Coord(ni, nj, k, moves+1));
            }
        }

        // 말처럼 이동하는 경우
        if (k<K) {
            for (int d=0; d<8; d++) {
                int ni = ti + hi[d];
                int nj = tj + hj[d];

                if (ni>=0 && ni<H && nj>=0 && nj<W) {
                    if (arr[ni][nj] == 1) continue;
                    if (visited[ni][nj][k+1]) continue;

                    visited[ni][nj][k+1] = true;
                    q.offer(new Coord(ni, nj, k+1, moves+1));
                }
            }
        }
    }
    // while문을 빠져나갈때까지 도착점에 가지 못한 경우
    return -1;
}
```

