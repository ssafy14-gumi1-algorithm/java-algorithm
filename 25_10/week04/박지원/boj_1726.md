# 요구사항 분석

출발 지점, 출발 방향, 도착 지점, 도착 방향이 주어질 때, 최소 명령 횟수 구하기

명령1: 1칸/2칸/3칸 전진
명령2: 오른쪽 90도 회전/ 왼쪽 90도 회전

출발지점에서 도착지점까지는 항상 이동이 가능하다.

## 입력

첫째 줄에 배열 세로 길이 M과 가로 길이 N(M과 N은 둘 다 100이하의 자연수)

m개의 줄에 배열 상태 주어짐

다음 줄에는 로봇의 출발 지점의 위치 (행과 열의 번호)와 바라보는 방향

마지막 줄에는 로봇의 도착 지점의 위치 (행과 열의 번호)와 바라보는 방향

방향은 동쪽이 1, 서쪽이 2, 남쪽이 3, 북쪽이 4로 주어진다.

## 출력(목표)

첫째 줄에 로봇을 도착 지점에 원하는 방향으로 이동시키는데 필요한 최소 명령 횟수

# 왜 코드를 그렇게 짰는지

이 문제는 보자마자 3차원 visited가 필요하겠구나 생각함 (하나의 칸에 여러 방향으로 방문할 수 있어서)

방향 번호가 주어지는데, 그 번호대로 dx, dy 만들었다가 오른쪽 90도 회전, 왼쪽 90도 회전이 제대로 되지 않아서 시간이 좀 걸렸음

왼쪽 90도 회전 visited 안 한 상태면 queue에 넣기

오른쪽 90도 회전 visited 안 한 상태면 queue에 넣기

1, 2, 3전진 중에 벽 만나면 그 뒤로는 못 가므로 break해서 전진 종료

# 핵심 로직

```java
public static int bfs(int startX, int startY, int startDir) {
    Queue<Coord> queue = new ArrayDeque<>();
    // 시작점 넣기
    queue.offer(new Coord(startX, startY, startDir, 0));
    visited[startX][startY][startDir] = true;

    while (!queue.isEmpty()) {
        Coord curr = queue.poll();
        // System.out.println(String.format("[%d] (%d, %d): %d", curr.cnt, curr.x, curr.y, curr.dir));

        // [종료조건] 도착 지점 + 도착 방향이 맞으면
        if (curr.x == endX && curr.y == endY && curr.dir == endDir) {
            return curr.cnt;
        }

        // [회전] 시계 방향
        int nd = (curr.dir + 1) % 4;
        if (!visited[curr.x][curr.y][nd]) {
            queue.offer(new Coord(curr.x, curr.y, nd, curr.cnt + 1));
            visited[curr.x][curr.y][nd] = true;
        }

        // [회전] 반시계방향
        nd = (curr.dir + 3) % 4;
        if (!visited[curr.x][curr.y][nd]) {
            queue.offer(new Coord(curr.x, curr.y, nd, curr.cnt + 1));
            visited[curr.x][curr.y][nd] = true;
        }

        // 도착지점에 왔으면 이동은 이제 할 필요 없음
        if (curr.x == endX && curr.y == endY) continue;

        // [이동] 1, 2, 3
        for (int k = 1; k <= 3; k++) {
            int nx = curr.x + (dx[curr.dir] * k);
            int ny = curr.y + (dy[curr.dir] * k);

            // 배열 밖 이동x
            if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;
            // System.out.println(String.format("target: (%d, %d)-%d", nx, ny, curr.dir));
            // 재방문x
            if (visited[nx][ny][curr.dir]) continue;
            // 로봇이 못 가는 장소
            if (map[nx][ny] == 1) break;

            queue.offer(new Coord(nx, ny, curr.dir, curr.cnt + 1));
            visited[nx][ny][curr.dir] = true;
        }

    }

    // 이런 경우는 없음
    return -1;
}
```

# 제출

![img.png](Attached/boj_1726.png)