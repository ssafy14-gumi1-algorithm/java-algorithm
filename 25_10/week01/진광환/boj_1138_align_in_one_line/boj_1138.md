# BOJ 1189 - 컴백홈

## 요구사항 분석

-   **입력**
    -   첫 번째 줄: 세로 길이 `R`, 가로 길이 `C`, 목표 거리 `K` (1 ≤ R, C ≤ 5, 1 ≤ K ≤ R×C)
    -   이후 `R`개 줄: `.` (갈 수 있는 곳)과 `T` (갈 수 없는 곳)으로 구성된 `R x C` 크기의 지도 정보

-   **출력**
    -   집(좌측 하단)에서부터 거리가 `K`인 경로로 학교(우측 상단)에 도착할 수 있는 모든 경우의 수를 정수로 출력

-   **문제 목표**
    -   주어진 `R x C` 지도에서, 출발점 `(R-1, 0)`에서 도착점 `(0, C-1)`까지, 장애물(`T`)을 피하고 갔던 길을 다시 가지 않으면서, 정확히 거리 `K`만큼 이동하는 경로의 개수를 찾는 것.

-   **시간 복잡도**
    -   `R`과 `C`의 최댓값이 5로 매우 작기 때문에, 모든 경로를 탐색하는 완전 탐색(Brute-force) 방식이 허용됩니다. 시간 복잡도는 지수 시간이지만, 제약 조건 내에서 충분히 해결 가능합니다.

***

## 풀이 및 작성 이유

- 이 문제는 최단거리가 아닌 특정거리를 만족하는 모든 경우의 수를 찾는 문제임
- bfs로도 풀 수 있을 것이라고 생각했지만 일단 둘 중 더 쉬운 방법이라고 생각되는 방법을 통해 풀어보기로 했음
- 또한 특정 길이에 도달하면 탐색을 중단하는 백트래킹을 사용해야 하기 때문에 dfs가 더 적절하다고 판단했음
- 최단거리에 상관없이 일정 길이의 경로를 탐색하는 알고리즘은 dfs가 더 적절하다고 판단함

***

## 함수 설명


-   `dfs(int cur_i, int cur_j, int dist)`
    -   현재 위치 `(cur_i, cur_j)`와 현재까지의 이동 거리 `dist`를 인자로 받는 재귀 함수
    -   **기저 조건 (Base Case)**:
        -   `dist`가 목표 거리 `K`에 도달했을 때, 현재 위치가 도착점 `(0, C-1)`인지 확인. 만약 도착점이라면, 유효한 경로이므로 `result`를 1 증가시키고 함수를 종료합니다.
        -   거리가 `K`가 되었지만 도착점이 아니거나, 거리가 `K`를 초과하면 더 이상 탐색할 의미가 없으므로 즉시 함수를 종료합니다.
    -   **재귀 (Recursive Step)**:
        -   현재 위치에서 상, 하, 좌, 우 네 방향으로 이동 가능한지 검사합니다.
        -   다음 위치가 (1) 지도 범위를 벗어나지 않고, (2) 장애물(`'T'`)이 아니며, (3) 현재 경로에서 아직 방문하지 않은 곳(`!visited[ni][nj]`)이라면,
            1.  `visited[ni][nj] = true;` // 다음 위치를 방문 처리 (전진)
            2.  `dfs(ni, nj, dist + 1);` // 거리를 1 늘려 재귀 호출
            3.  `visited[ni][nj] = false;` // **(백트래킹)** 탐색 완료 후, 방문 상태를 해제하여 다른 경로에서 이 칸을 사용할 수 있도록 함

***

## 배운 점/개선점

- bfs뿐만 아니라 dfs로 문제를 풀 때 더 쉬운 경우가 있다는 것을 알 수 있었음
- 다음에는 이 문제를 bfs로도 풀어볼 수 있겠다