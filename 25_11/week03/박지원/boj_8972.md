# 요구사항 분석
.:빈칸, R: 미친 아두이노, I: 종수
1. 종수가 움직이고 싶은 방향으로 움직인다(입력으로 주어짐)
   - 종수의 아두이노가 미친 아두이노 칸으로 이동하면 패
2. 미친 아두이노는 8방향 중 종수의 아두이노와 가장 가까워지는 방향으로 한 칸 이동
    - 미친 아두이노가 종수의 아두이노 칸으로 이동하면 패배
    - 2개 이상의 미친 아두이노가 같은 칸으로 이동하면 해당 칸의 아두이노는 모두 파괴

주어진 방향대로 움직였을 때, 보드 상태(패배 시 몇 번 움직였는지 출력)

## 입력
r c

r개 줄: c개의 문자(.:빈칸, R: 미친 아두이노, I: 종수)

종수가 움직이고 싶은 방향

## 출력(목표)
이동을 마쳤을 시: 보드 상태 출력

패배 시 :"kraj X"를 출력한다. X는 종수가 게임이 끝나기 전 까지 이동한 횟수

# 왜 코드를 그렇게 짰는지
주어진 지문대로 코드를 짜면 됨. 제자리까지 포함한 dx, dy 선언

종수 움직이고 그 자리에 아두이노 있으면 false 반환(게임 오버)

아두이노 하나씩 움직일 방향 정하기(모든 방향에 대해 최소 거리 찾기)

int 배열에 아두이노 개수 1개씩 더하기 -> 1개인 칸만 남기고 싹 다 아두이노 삭제

# 핵심 로직
```java
String command = br.readLine();
for (int i = 0; i < command.length(); i++) {
    int dir = command.charAt(i) - '0'; // 1 ~ 9

    // 1. 종수 이동
    if (!movePlayer(dir)) {
        System.out.println("kraj " + (i + 1));
        return;
    }

    // 2. 미친 아두이노 이동
    if (!moveEnemies()) {
        System.out.println("kraj " + (i + 1));
        return;
    }
}

// 모든 명령을 수행하고 살아남은 경우 최종 보드 출력
printBoard();
```
# 제출
![img.png](boj_8972.png)