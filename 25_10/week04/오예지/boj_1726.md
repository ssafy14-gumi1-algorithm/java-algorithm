# 요구사항 분석
출발지점과 도착지점이 주어지는데, 도착지점가지 가는 최소한의 명령 횟수를 구하라.

- 명령 1. Go k: k는 1, 2 또는 3일 수 있다. 현재 향하고 있는 방향으로 k칸 만큼 움직인다.
- 명령 2. Turn dir: dir은 left 또는 right 이며, 각각 왼쪽 또는 오른쪽으로 90° 회전한다.

## 입력
첫째 줄에 공장 내 궤도 설치 상태를 나타내는 직사각형의 세로 길이 M과 가로 길이 N이 빈칸을 사이에 두고 주어진다.\
이때 M과 N은 둘 다 100이하의 자연수이다. 이어 M줄에 걸쳐 한 줄에 N개씩 각 지점의 궤도 설치 상태를 나타내는 숫자 0 또는 1이 빈칸을 사이에 두고 주어진다.\
다음 줄에는 로봇의 출발 지점의 위치 (행과 열의 번호)와 바라보는 방향이 빈칸을 사이에 두고 주어진다.\
마지막 줄에는 로봇의 도착 지점의 위치 (행과 열의 번호)와 바라보는 방향이 빈칸을 사이에 두고 주어진다.\
방향은 동쪽이 1, 서쪽이 2, 남쪽이 3, 북쪽이 4로 주어진다.\
출발지점에서 도착지점까지는 항상 이동이 가능하다.

## 출력(목표)
첫째 줄에 로봇을 도착 지점에 원하는 방향으로 이동시키는데 필요한 최소 명령 횟수를 출력한다.

# 왜 코드를 그렇게 짰는지
1. 같은 칸이여도 동, 서, 남, 북 네 가지 방향이 있어서 3차원 배열이 필요하다고 생각했음
2. 해당 칸에서 왼쪽, 오른쪽, 방향 유지 세가지 경우를 생각하고, 해당 방향으로 1~3칸 직진하는 경우도 생각함
3. 그래서 bfs로 풀었다~

# 핵심 로직
```declarative
// Turn dir -> 회전하지 않음, 왼쪽, 오른쪽
for (int dir=0; dir<3; dir++) {
    if (dir==0) {			// 회전하지 않음
        continue;
    }else {
        int newDir;
        if(dir==1) {		// 왼쪽으로 회전
            if (td==1) {
                newDir = 4;
            }else if(td==2) {
                newDir = 3;
            }else if(td==3) {
                newDir = 1;
            }else {
                newDir = 2;
            }
        }else {				// 오른쪽으로 회전
            if (td==1) {
                newDir = 3;
            }else if(td==2) {
                newDir = 4;
            }else if(td==3) {
                newDir = 2;
            }else {
                newDir = 1;
            }
        }
        if (!visited[ti][tj][newDir]) {
            visited[ti][tj][newDir] = true;
            q.add(new Coord(ti, tj, newDir, move+1));
        }
    }
}
```

```declarative
// Go k
for (int k=1; k<=3; k++) {
    int ni = ti + di[td]*k;
    int nj = tj + dj[td]*k;
    int nd = td;

    // 범위를 벗어나면 for문을 종료
    if (ni<=0 || ni>M || nj<=0 || nj>N) break;

    if (field[ni][nj] == 1) break;

    // 이미 같은 방향으로 해당 칸을 방문한 적이 있거나 갈 수 없는 공간
    if (visited[ni][nj][nd]) continue;

    visited[ni][nj][nd] = true;
    q.add(new Coord(ni, nj, nd, move+1));

}
```
