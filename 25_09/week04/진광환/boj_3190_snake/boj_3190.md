

## 요구사항 분석

| 항목              | 내용                                                                                                                                                                                                                  |
|:----------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **입력 (Input)**  | 보드 크기 **$N$** ($2 \le N \le 100$), 사과의 개수 **$K$**, 방향 변환 횟수 **$L$**, $K$개의 사과 위치, $L$개의 방향 변환 정보($X$초 후 $C$ 방향으로 회전).                                                                                               |
| **출력 (Output)** | 게임이 끝나는 **시간(초)**.                                                                                                                                                                                                  |
| **문제 목표**       | 뱀이 **벽** 또는 **자신의 몸**에 부딪힐 때까지 이동했을 때, 그 때까지 걸린 **시간**을 계산하는 시뮬레이션 문제.                                                                                                                                              |
| **시간복잡도**       | 최대 보드 크기 $N=100$, 최대 시간 $T$가 매우 클 수 있지만, 뱀의 움직임을 시뮬레이션하는 과정은 한 번의 이동에 **$O(1)$** 시간이 소요됩니다. 뱀의 최대 길이도 $N^2$이므로, 전체 시간 복잡도는 게임이 끝나는 최대 시간 $T$에 비례하는 **$O(T)$**가 됩니다. $T$는 최대 $10,000$초로 주어지므로 **충분히 시간 내 해결 가능**합니다. |

***

## 풀이 및 작성 이유

구현 할게 많은 전형적인 시뮬레이션 문제임, 머리 위치는 까다롭지 않으나 꼬리 위치를 갱신하는 과정이 어려웠음
### 1. 뱀의 상태 표현 (자료구조 선택)

* **뱀의 몸**: 뱀의 머리와 꼬리를 포함한 전체 위치를 순서대로 추적해야 함 뱀은 머리가 늘어나고 꼬리가 줄어들기 때문에 **FIFO (선입선출)**와 **LIFO (후입선출)** 특성을 모두 가진 *
  *`Deque` (Double-Ended Queue)** 또는 **`LinkedList`**가 가장 적합. 코드에서는 `ArrayDeque`를 사용했습니다.
    * **머리 이동**: `addFirst()`를 사용하여 새로운 머리 위치를 추가.
    * **꼬리 제거**: 사과를 먹지 않은 경우 `removeLast()`를 사용하여 꼬리 위치 제거.
    * 
* **보드 상태**: 사과와 뱀의 위치를 구분하기 위해 2차원 배열 `arr`를 사용
    * `arr[i][j] = 0`: 빈 공간
    * `arr[i][j] = 1`: 뱀의 몸
    * `arr[i][j] = 2`: 사과

### 2. 게임 로직 (Main Loop)

> `snakeCanMove()` : 뱀이 움직일 수 있으면 <br>
> `moveSnake` : 움직이고 <br>
> `time ++` : 시간을 늘린 후 <br>
> `decideDirection` : 방향 결정하기 


***

## 함수 설명

| 함수 이름                 | 매개변수                        | 반환 값             | 설명                                                                                                            |
|:----------------------|:----------------------------|:-----------------|:--------------------------------------------------------------------------------------------------------------|
| **`solve`**           | 없음                          | `int` (게임 종료 시간) | 뱀의 움직임을 시뮬레이션하는 **메인 루프**입니다. `snakeCanMove`가 `false`가 될 때까지 뱀을 이동시키고 시간을 증가시킵니다.                             |
| **`snakeCanMove`**    | `i_idx`, `j_idx` (현재 머리 위치) | `boolean`        | **다음 이동할 위치**가 **보드 경계 내**에 있고, 그 위치에 **자신의 몸이 없는지** 확인하여 이동 가능 여부를 반환합니다.                                    |
| **`moveSnake`**       | 없음                          | `void`           | 뱀을 한 칸 이동시킵니다. 새로운 머리 위치에 사과($2$)가 있는지 확인하고, 사과가 없다면 꼬리(`removeLast`)를 제거하고 보드에서 지웁니다.                        |
| **`decideDirection`** | `time` (현재 시간)              | `void`           | 현재 시간 `time`에 방향 전환 명령(`commands[time]`)이 있는지 확인하고, 있다면 뱀의 **`direction`**을 'L' (좌회전) 또는 'D' (우회전)에 따라 변경합니다. |

***

## 배운 점/개선점

### 1. 배운 점: 시뮬레이션 문제의 구조화

* Deque를 사용하면서 후입선출, 선입선출 구조 외에 자료구조를 응용하는 방법을 깨달았음, 스택과 큐에만 매몰되어있었는데 이번 계기를 통해 새롭게 문제를 푸는 방법을 알 수 있었음
* Main함수 내에 class를 따로 정의하는 방법을 이번에 처음 사용해봄, 그 전에는 int[] 타입을 집어넣는 제네릭 타입을 사용했는데 이번기회에 더 자바스러운 풀이방법을 적용해볼 수 있었음