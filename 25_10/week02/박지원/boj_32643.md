# 요구사항 분석

$1$부터 $N$까지 한 개씩 들어있는 수열을 만드는 것이 목표

이를 위해 최소 개수의 양의 정수가 들어있는 수열을 준비했고, 목표를 달성할 때까지 다음 작업들을 반복했다.

1. 수열에 있는 한 정수를 제곱한 수를 수열에 추가한다.
2. 수열에 있는 두 정수를 곱한 수를 수열에 추가한다.

익준이는 모든 작업을 마친 정민이를 보고 어떤 정수들을 가지고 처음 작업을 시작했는지 물었다.

익준이는 질문을 총 $M$번 할 것이다.

익준이가 $a$와 $b$를 물어보면 초기 정수 중 $a$ 이상 $b$ 이하인 정수들의 개수를 알려 주겠다고 했다.

## 입력

첫 번째 줄에 정수 N,M이 공백으로 구분되어 주어진다. $(1 \le N \le 5\,000\,000;1 \le M \le 1\,000\,000)$

두 번째 줄부터 $M$개의 줄에 정수 $a,b$가 공백으로 구분되어 주어진다.
$(1 \le a \le b \le N)$

## 출력(목표)

$M$개의 줄에 각 질문의 답을 출력한다.

# 왜 코드를 그렇게 짰는지

문제가 좀 이해하기 어려웠다.

1부터 N까지 한 개 씩 들어있는 수열을 만들기 위해 최소 수열을 준비했고, 익준이는 이 수열에 a이상 b이하 수가 몇 개인지 물어본다.

수열에 있는 정수를 제곱하여 추가, 수열에 있는 두 정수를 곱하여 수열해 추가하는 작업을 반복해서, 1~N까지 숫자가 하나씩 들어있는 수열을 만들 수 있어야 함

1~10을 하나씩 만들기 위해 최소 수열에 필요한 수들을 생각해 보자

- 1 어떤 수로도 만들 수 없으므로 초기 수열에 필요함
- 2 마찬가지로 어떤 수로도 만들 수 없음(제곱, 곱셈으로 만들 수 없음
- 3 마찬가지
- ~~4 2*2로 만들 수 있으므로 필요하지 않음~~
- 5 제곱, 곱셈으로 만들 수 없음
- ~~6 2*3으로 만들 수 있으므로 필요하지 않음~~
- 7 제곱, 곱셈으로 만들 수 없음
- ~~8 2*4로 만들 수 있음~~
- ~~9 3*3으로 만들 수 있음~~
- ~~10 2*5로 만들 수 있음~~

⇒ 1~10까지 최소 수열은 {1, 2, 3, 5, 7} 1을 제외하면 10까지 소수 집합이 된다.

질의가 100만개이므로 미리 i까지 소수 개수를 구해두는 게 빠르다

# 핵심 로직

소수 개수 누적합 배열 prefixSum[]

i번째 값이 소수면 이전 누적 합에 1 더한 값을 저장하고, 소수가 아니면 이전에 값을 저장한다

```java

public static void main(String[] args) throws IOException {
    // 소수 배열 만들기(에라토스테네스의 체)
    primes = new boolean[n + 1];
    Arrays.fill(primes, true);
    for (int i = 2; i * i <= n; i++) {
        if (!primes[i]) continue;

        for (int j = i * i; j <= n; j += i) {
            primes[j] = false;
        }
    }

    // 질의가 100만개라서 i까지의 소수의 개수를 미리 계산해둬야 빠름
    int[] prefixSum = new int[n + 1];
    prefixSum[1] = 1; // 1은 소수가 아니지만 수열을 만들 때 필요하므로 소수 취급 함
    for (int i = 2; i <= n; i++) {
        prefixSum[i] = (primes[i]) ? prefixSum[i - 1] + 1 : prefixSum[i - 1];
    }

    // m개의 질문에 대답
    int cnt = prefixSum[b] - prefixSum[a];
    if (primes[a]) cnt++;

}
```

# 제출

![img.png](Attached/boj_32643.png)