# 요구사항 분석
최대최소

- N×N의 행렬이 있다(1 ≤ N ≤ 250).
- 행렬의 각 성분은 250보다 작거나 같은 음이 아닌 정수이다.
- 당신에게는 K(1 ≤ K ≤ 100,000)개의 질문이 주어진다.
- 각 질문은, 주어진 행렬의 B×B 크기의 부분행렬의 최댓값과 최솟값의 차이를 묻는 질문들이다(1 ≤ B ≤ N).
- 각 질문에 대해서, 부분행렬의 가장 왼쪽 위의 위치가 주어지며, 모든 질문들은 같은 B값을 갖는다.
- 질문에 답하는 프로그램을 작성하시오.
## 입력
- 첫째 줄에는 세 정수 N, B, K가 주어진다.
- 다음 N개의 줄에는 행렬이 주어진다.
- 차례로 1행, 2행, …, N행이 된다.
- 각 줄에는 N개의 정수가 주어지며, 이는 차례로 1열의 성분, 2열의 성분, …, N열의 성분이 된다.
- 다음 K개의 줄에는 질문들이 주어진다.
- 각 질문들은 두 정수 i, j로 주어진다.
- i는 부분행렬의 가장 윗쪽의 행 번호이며, j는 부분행렬의 가장 왼쪽의 열 번호이다(1 ≤ i, j ≤ N-B+1)
## 출력(목표)
- K개의 줄에, 차례로 각 질문의 답변(부분행렬의 최댓값과 최솟값의 차이값)을 출력한다.
# 왜 코드를 그렇게 짰는지
- AI 수업때 들었던 뭔가뭔가랑 비슷해보임
- 근데 행렬이 250 * 250임 62,500 => 시간초과 나기 딱이네
- K가 10만이라 무식하게 반복문 돌려서 풀려고하면 62억5천만이 나옴
- 슬라이딩 윈도우를 사용해서 N-B+1짜리 2차원 행렬로 만들어서 K 좌표에 해당하는 값을 O(1)로 가져올 수 있을거 같았음
# 핵심 로직
## 슬라이딩 윈도우 로직으로 N-B+1짜리 최대 - 최소 2차원 행렬 만들기
- 250 * 250 행렬 안에서 K를 순회하는 코드까지 넣어서 답을 구할순 있겠지만 시간복잡도가 터짐
- 그래서 미리 K에 대한 정답들만을 담은 배열들을 만들어두고, k개의 질문들을 인덱싱으로 O(1)만에 구하면 시간초과가 안 남
- 슬라이딩 윈도우로 정답 배열 구하는것도 최대 (250 - B + 1) * (250 - B + 1) * B^2
- B가 1 ~ 250이라서 얼추 생각해봐도 1억을 넘길일은 없음
```java
// 압축시킬 배열
int size = N - B + 1;
int[][] pressArr = new int[size][size];

// 배열 압축시키기
for (int y = 0; y <= N - B; y++) {
    for (int x = 0; x <= N - B; x++) {
        int minV = 251;
        int maxV = 0;
        // B * B 행렬 최소, 최대 구하기
        for (int i = 0; i < B; i++) {
            // 행 최솟값 / 최댓값 (arr[y+i][x .. x+B-1])
            int rowMin = 251;
            int rowMax = 0;
            for (int c = x; c < x + B; c++) {
                int v = arr[y + i][c];
                if (v < rowMin) rowMin = v;
                if (v > rowMax) rowMax = v;
            }
            if (minV > rowMin) minV = rowMin;
            if (maxV < rowMax) maxV = rowMax;
        }
        // 압축 행렬에 최대 - 최소값 담아주기
        pressArr[y][x] = maxV - minV;
    }
}
```
