# 요구사항 분석
- X와 구성이 같으면서 X보다 큰 수 중 가장 작은 수(수의 구성이 같다는 말은, 수를 이루고 있는 각 자리수가 같다는 뜻)
- 예를 들어, 123과 321은 수의 구성이 같다. 하지만, 123과 432는 구성이 같지 않다.
## 입력
- 첫째 줄에 X가 주어진다. (1 ≤ X ≤ 999999) X는 0으로 시작하지 않는다.

## 출력(목표)
- 정수 X가 주어졌을 때, X와 구성이 같으면서 X보다 큰 수 중 가장 작은 수를 출력
- 그러한 숫자가 없는 경우에는 0을 출력

# 왜 코드를 그렇게 짰는지
- 문자열 X로 만들 수 있는 모든 조합을 만들고, 거기서 X보다 큰 바로 다음 문자열을 출력해야 함
- 부분집합으로 다 구해서 X길이만 구하는 방식은 너무 비효율적인거 같고, DFS를 활용해서 X의 길이에 해당하는 모든 문자열 조합을 구하면 되지 않을까 생각함.
- 모든 문자열 조합을 구하고, 그걸 반복문 돌려서 X보다 큰 숫자 나왔을때 그 숫자를 return하면 답일거 같았음.

# 핵심 로직
## DFS 활용해 X의 모든 문자열 조합 구하기
```java
// combination에서 결과값 찾는 함수
public static void getComb(String X, int now_idx, String word, int length, boolean[] visited){
    // 사용여부 확인
    if(!visited[now_idx]){
        return;
    }

    // 사용 체크
    visited[now_idx] = false;

    // 현재 문자 추가
    word += X.charAt(now_idx);

    // 문자열 완성됐으면 combination에 추가
    if(length == X.length()){
        combinations.add(word);
        return;
    }

    for(int next_idx = 0; next_idx < X.length(); next_idx++){
        if(next_idx != now_idx){
            // 자바 얕은복사는 clone()이란 메서드가 있네
            // 뭔 파이썬, JS, 자바 전부 다 달라 미쳐버리겠네;;
            getComb(X, next_idx, word, length + 1, visited.clone());
        }
    }
}

// main에서 실행했을때 예시
String X = br.readLine();

for(int i = 0; i < X.length(); i++){
    // 사용 여부 체크
    boolean[] visited = new boolean[X.length()];
                Arrays.fill(visited, true);
    
    // 조합 구하는 DFS 실행
    getComb(X, i, "", 1, visited);
}
```
- 해당 인덱스를 사용했다는 boolean배열인 visited를 DFS별로 참조를 공유하지 않도록 얕은 복사를 사용하는게 포인트
- DFS 동안 visited를 공유하게 된다면 visited가 순식간에 전부 체크됨으로 바뀌면서 DFS 실행이 정상적으로 진행될 수 없음
- 방문하지 않은 지역일 경우에 word에 현재 문자열을 추가한다.
- 문자열이 모두 완성되었을 경우, 전역으로 관리하고 있는 조합 담는 배열 combinations에 추가해주고 return 해주면 됨.
- DFS문을 main에서 실행한다고 치면 시작점은 for문을 통해 하나씩 지정해줘서 실행시켜줘야 모든 문자열 조합을 구할 수 있겠쥬
