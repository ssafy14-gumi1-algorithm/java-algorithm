# 요구사항 분석
입력으로 주어진 방향대로 종수가 움직였을 때, 보드의 상태를 구하는 프로그램을 작성
중간에 게임에서 지게된 경우에는 몇 번째 움직임에서 죽는지를 구한다

## 입력
첫째 줄에 나라의 개수 N과 항공편의 개수 M이 주어진다. (1 <= N <= 200,000; 0 <= M <= 500,000)
둘째 줄부터 M개의 줄에 걸쳐 항공편의 정보가 두 정수 v, w로 주어진다.
이는 v번 나라에서 출발해 w번 나라로 가는 항공편을 의미한다.(1 <= v,w <= N; v != w)

## 출력(목표)
시작점을 어떻게 골라도 모든 나라를 방문할 수 있는 경로가 있다면 Yes를, 아니면 No를 출력한다.

# 왜 코드를 그렇게 짰는지
1번 노드부터 정방향으로 인접한 노드들을 전부 방문하고
역방향으로 인접한 노드들을 전부 방문할 수 있다면
어떤 노드를 시작점으로 하더라도 1번 노드를 거친다면 모든 노드를 방문할 수 있다.

# 핵심 로직
```declarative
// 정방향 bfs
visited = new boolean[N+1];
bfs(1, adjList);
for (int i=1; i<=N; i++){
    if (!visited[i]){
        System.out.println("No");
        return;
    }
}

// 역방향 bfs
visited = new boolean[N+1];
bfs(1, reverse);
for (int i=1; i<=N; i++){
    if (!visited[i]){
        System.out.println("No");
        return;
    }
}
```