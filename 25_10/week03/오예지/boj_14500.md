# 요구사항 분석
정사각형 네개를 이어 붙인 것 -> 테트로미노

테트로미노 하나를 적절히 놓아서 칸의 쓰여 있는 수들의 합을 최대로 하는 프로그램을 작성

## 입력
첫째 줄에 종이의 세로 크기 N과 가로 크기 M이 주어진다. (4 ≤ N, M ≤ 500)

둘째 줄부터 N개의 줄에 종이에 쓰여 있는 수가 주어진다.\
i번째 줄의 j번째 수는 위에서부터 i번째 칸, 왼쪽에서부터 j번째 칸에 쓰여 있는 수이다. \
입력으로 주어지는 수는 1,000을 넘지 않는 자연수이다.

## 출력(목표)
첫째 줄에 테트로미노가 놓인 칸에 쓰인 수들의 합의 최댓값을 출력한다.

# 왜 코드를 그렇게 짰는지
최대의 값을 구하는 거여서 완전 탐색이라고 생각합
그래서 4중 for문을 돌렸는데 조금 더 좋은 방법이 있지 않을까..
-> GPT한테 물어보니까 정해는 DFS라고 함

세로로 2개를 이어붙인 블록과 가로로 2개 이어붙인 블록이 있다고 생각을 했을 때,\
각 블록에 붙있을 수 있는 경우는 6가지 중 2개를 고르는 것
여기서 2중 for문을 사용해서 조합을 구하는 바람에 4중 for문이 됨..

# 핵심 로직
누워있는 블럭 기준으로 코드를 가져옴
```declarative
// 6 부분의 블록의 위치를 기준점을 잡아서 배열을 만들어줌
static int[] block1X = {-1, -1, 0, 1, 1, 0};
static int[] block1Y = {0, 1, 2, 1, 0, -1};

int maxSum = 0;
// 누워있는 블럭
for (int i=0; i<N; i++) {
    for (int j=0; j<M-1; j++) {
    // 0부터 5까지의 숫자 중에서 2개를 조합
        for (int x=0; x<6; x++) {
        // block1
            int ni1 = i + block1X[x];
            int nj1 = j + block1Y[x];
            
            // 범위를 벗어나는 블럭
            if (ni1<0 || ni1>=N || nj1<0 || nj1>=M) continue;
            
            for (int y=x+1; y<6; y++) {
                // block2
                int ni2 = i + block1X[y];
                int nj2 = j + block1Y[y];
                
                // 범위를 벗어나는 블럭
                if (ni2<0 || ni2>=N || nj2<0 || nj2>=M) continue;
                
                // 두 블럭 다 범위에 있다면
                int totalSum = arr[i][j]+arr[i][j+1]
                + arr[ni1][nj1] + arr[ni2][nj2];
                
                maxSum = Math.max(maxSum, totalSum);
                }
        }
    }
}
```


