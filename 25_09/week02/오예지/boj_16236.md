# 요구사항 분석
상어 성장 조건
- 처음 크기는 2
- 자기보다 작은 물고기만 먹을 수 있음
- 자기보다 큰 물고기는 아예 못 지나감
- 물고기를 size 마리 먹을 때마다 size+=1

시간 측정
- 한 칸 이동할 때마다 시간이 1씩 증가

물고기 우선순위
1. 거리가 가장 가까운 물고기
2. 가장 위에 있는 물고기, 가장 왼쪽에 있는 물고기
   -> 같은 거리에 물고기가 여러마리 있다면 i, j의 값이 가장 작은 물고기 부터 방문

## 입력
첫째 줄에 공간의 크기 N(2 ≤ N ≤ 20)이 주어진다.

둘째 줄부터 N개의 줄에 공간의 상태가 주어진다. 공간의 상태는 0, 1, 2, 3, 4, 5, 6, 9로 이루어져 있고, 아래와 같은 의미를 가진다.

0: 빈 칸
1, 2, 3, 4, 5, 6: 칸에 있는 물고기의 크기
9: 아기 상어의 위치
아기 상어는 공간에 한 마리 있다.

## 출력(목표)
첫째 줄에 아기 상어가 엄마 상어에게 도움을 요청하지 않고 물고기를 잡아먹을 수 있는 시간을 출력한다.

# 왜 코드를 그렇게 짰는지
1. 해당 위치에서 물고기가 있는 위치까지의 거리를 알아내기 위해서 BFS 사용
2. 상어가 해당 위치에서 먹을 수 있는 모든 물고기를 (거리, 행, 열)로 묶어서 넣어주고, 정렬해주면 어떤 물고기를 먹으러 갈지 정할 수 있을거라고 생각함

# 핵심 로직
주변에 있는 물고기를 찾는 부분
```declarative
static List<int[]> findFish(int si, int sj, int size){
    Queue<int[]> q = new ArrayDeque<>();
    int[][] visited = new int[N][N];
    // visited 배열을 만드는데, -1로 채워줌
    for (int [] row : visited) Arrays.fill(row, -1);

    q.add(new int[]{si, sj});
    visited[si][sj] = 0;

    List<int[]> fish = new ArrayList<>();

    while (!q.isEmpty()){
        int[] cur = q.poll();
        int ci = cur[0];
        int cj = cur[1];

        for (int d = 0; d < 4; d++){
            int ni = ci + di[d];
            int nj = cj + dj[d];

            if (ni >= 0 && ni < N && nj >= 0 && nj < N && visited[ni][nj] == -1){
                if (arr[ni][nj] <= size){
                    visited[ni][nj] = visited[ci][cj] + 1;
                    q.add(new int[]{ni, nj});

                    if (arr[ni][nj] > 0 && arr[ni][nj] < size){
                        fish.add(new int[]{visited[ni][nj], ni, nj});
                    }
                }
            }
        }
    }
    return fish;
}
```

찾은 물고기들에서 우선순위대로 정렬
```declarative
fish.sort((a, b) -> {
    if (a[0] != b[0]) return a[0] - b[0];  // 거리가 가까운 순
    if (a[1] != b[1]) return a[1] - b[1];  // 위쪽에 있는 순
    return a[2] - b[2];                    // 왼쪽에 있는 순
});
```
