

## 요구사항 분석

- **입력**
    - 첫째 줄에 N (1 ≤ N ≤ 15): 상담할 수 있는 날짜의 수
    - 둘째 줄부터 N개의 줄: 각 줄마다 Ti, Pi (1 ≤ Ti ≤ 5, 1 ≤ Pi ≤ 1,000)
        - Ti: 상담에 걸리는 기간
        - Pi: 상담을 했을 때 받을 수 있는 금액

- **출력**
    - 퇴사일까지 상담을 해서 얻을 수 있는 *최대 이익* 출력

- **문제 목표**
    - 날짜별로 상담 일정이 주어지며, 상담이 겹치지 않게 최대 수익을 계산

- **변수의 범위**
    - N의 최대값이 15이므로 완전탐색(재귀, dp 등)으로 시간 내 해결 가능

- **시간 복잡도**
    - 완전탐색을 해도 $$O(2^N)$$ 수준이므로 15 기준으로 충분히 빠름

***

## 접근 및 풀이 설명

- 문제의 핵심은 *상담을 할지/말지*를 선택하고, 끝까지 탐색해보는 것
- 상담 일자와 받을 수 있는 급여를 각각 함수의 매개변수에 넣어서 재귀함수를 통해 모든 경우의 수를 탐색하기
- 종료조건
  - 재귀 깊이가 상담일자를 넘어갈 때 = 그냥 리턴하기
  - 재귀 깊이가 상담일자와 딱 맞을 때 = 현재 최대 이익과 cursum을 비교하여 최댓값 산출하기

***

## 함수 설명

- **recur(int idx, int cursum):**
    - 재귀로 두 가지 경우를 탐색
        - 1) 현재 상담을 실시: `recur(idx + arr[idx], cursum + arr[idx])`
        - 2) 상담을 실시하지 않음: `recur(idx + 1, cursum)`
    - 기저 조건에서 결과를 갱신

```java
static void recur(int idx, int cursum) {
    if (idx > N) return; // 배열 끝나면 return
    if (idx == N) {
        result = Math.max(cursum, result); // 최대 이익 갱신
        return;
    }
    recur(idx + arr[idx], cursum + arr[idx]); // 상담
    recur(idx + 1, cursum); // 상담하지 않음
}
```




## 배운 점/개선하고 싶은 점

- 한정된 N(15 이하)이면, 완전탐색(DFS/백트래킹)이 효율적임을 다시 한 번 확인
- 동적계획법(DP)로도 풀 수 있는데, DP로 변경해보면 메모리 사용량이나 이해가 더 쉬워질 수 있음
- 반복적으로 등장하는 스케줄링 완전탐색은 패턴화해두면 나중에 생산성이 높아질 것으로 생각함


