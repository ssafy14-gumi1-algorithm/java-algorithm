# 요구사항 분석
안전영역

- 어떤 지역의 높이 정보를 파악한다.
- 그 지역에 많은 비가 내렸을 때 물에 잠기지 않는 안전한 영역이 최대로 몇 개가 만들어 지는 지를 조사하려고 한다.
- 아무 지역도 물에 잠기지 않을 수도 있다.(이걸 왜 끝자락에 적어놨냐)

## 입력
- 첫째 줄에는 어떤 지역을 나타내는 2차원 배열의 행과 열의 개수를 나타내는 수 N이 입력된다.
- N은 2 이상 100 이하의 정수이다.
- 둘째 줄부터 N개의 각 줄에는 2차원 배열의 첫 번째 행부터 N번째 행까지 순서대로 한 행씩 높이 정보가 입력된다.
- 각 줄에는 각 행의 첫 번째 열부터 N번째 열까지 N개의 높이 정보를 나타내는 자연수가 빈 칸을 사이에 두고 입력된다.
- 높이는 1이상 100 이하의 정수이다.

## 출력(목표)
- 장마철에 물에 잠기지 않는 안전한 영역의 최대 개수를 출력한다.

# 왜 코드를 그렇게 작성했는지
- 안전한 영역이 붙어있는 경우에 1개로 취급함(영역이니깐)

- 장마는 아예 잠기는 일이 없는 경우 0과 모든 건물이 잠기는 경우인 높이의 최대값을 기준으로 모든 장마 캐이스를 테스트 해야함
- 시간복잡도는 전혀 문제 없으니 결과 카운트들을 배열 하나에 계속 담고, 그 배열의 최댓값을 출력해주면 될듯

- 문제는 그냥 섬 갯수 구하기 처럼 진행하는데 4방향 델타로 풀면 될듯

# 핵심 로직
## 1. 안전지역 갯수가 가장 많은 케이스 구하기
- 문제에선 장마가 발생해서 지역들이 물에 잠길때 가장 안전구역이 많은 지역을 찾으라고 함
- 그 말은 모든 지역이 잠기기 전 까지의 침수상태를 비교해 안전구역이 가장 많은 지역을 찾아내야함
- 그러니 입력받은 지역에서 가장 높은 지역을 찾아내고, 그 높이까지 반복문을 실행해 침수 케이스들을 전부 실행해봐야함
```java
area = new int[N][N];
int maxHeight = 0;

// 지역 입력 및 최대 높이 추출
for (int y = 0; y < N; y++) {
    StringTokenizer st = new StringTokenizer(br.readLine());
    for (int x = 0; x < N; x++) {
        // 지역 입력
        area[y][x] = Integer.parseInt(st.nextToken());
        // 최대 높이 추출
        if (area[y][x] > maxHeight) {
            maxHeight = area[y][x];
        }
    }
}
```
```java
// 가장 많은 안전지역 수 = result
int result = 0;

// 강수량 0부터 maxHeight - 1까지 테스트
for (int rainDeep = 0; rainDeep <= maxHeight; rainDeep++) {
    // 방문여부 생성
    visited = new boolean[N][N];
    // 깊이별로 안전구역 갯수 세기
    int safeAreaCount = 0;

    for (int y = 0; y < N; y++) {
        for (int x = 0; x < N; x++) {
            // 호우 깊이보다 현재 지역의 높이가 더 높은 경우 DFS 진행
            if (area[y][x] > rainDeep && !visited[y][x]) {
                dfs(x, y, rainDeep);
                safeAreaCount++;
            }
        }
    }
    // 현재 안전구역 갯수와 result중 더 큰값을 result값으로 재할당하기
    result = Math.max(result, safeAreaCount);
}
```

