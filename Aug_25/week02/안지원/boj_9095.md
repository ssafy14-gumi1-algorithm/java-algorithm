# 요구사항 분석
- 정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 7가지
- 정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성
## 입력
- 첫째 줄에 테스트 케이스의 개수 T가 주어진다.
- 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다(1 <= n <= 11)
## 출력(목표)
- 각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 출력
# 왜 코드를 그렇게 짰는지
- 1, 2, 3을 더해서 n을 달성하는 모든 경우의 수를 구하는 문제임
- 재귀함수를 실행시켜 1 + 1, 1 + 2, 1 + 3, 1 + 1 + 1, 1 + 1 + 2 ... 이렇게 모든 경우의 덧셈을 전부 실행시키면?
- n을 달성한 경우에만 카운트를 +1 해주고, 나머지는 전부 return 0 으로 끊어버리면 결과를 구할 수 있을거라 생각했음

# 핵심 로직
## 1, 2, 3 덧셈 재귀함수
``` java
private static int getCount(int num, int nowNum) {
    // nowNum이 num 보다 클 때 종료(0을 반환)
    // nowNum이 num과 동일한 경우 1 반환

    // 현재 값이 num을 만족하면 1 반환
    if(nowNum == num) {
        return 1;
    }
    // 현재 idx가 num을 넘어서면 0 반환
    if(nowNum > num) {
        return 0;
    }

    int count = 0;
    // 1, 2, 3 하나씩 순차적으로 더해주면서 진행
    for(int i = 0; i < numArr.length; i++) {
        count += getCount(num, nowNum + numArr[i]);
    }

    return count;
}

// DFS 적용
// 덧셈할 1, 2, 3 케이스들
static int[] numArr = {1, 2, 3};

public static void main(String[] args) throws IOException {
    BufferedReader br =  new BufferedReader(new InputStreamReader(System.in));
    int T = Integer.parseInt(br.readLine());

    // 테스트케이스만큼 반복문 실행
    for(int tc = 1; tc < T+1; tc++) {
        // 목표 숫자 받기
        int num = Integer.parseInt(br.readLine());

        // 결과값
        int result = 0;

        // 1, 2, 3 모든 케이스로 덧셈 DFS 시작
        for(int i = 0; i < numArr.length; i++) {
            result += getCount(num, numArr[i]);
        }

        System.out.println(result);
    }
}
```

- numArr은 nowNum에 더해줄 숫자(전역변수로 관리)
- 목표값 n(num)에 도달하거나, n을 넘어설 때 까지 1, 2, 3을 더해주는 재귀함수를 계속 실행
- n을 넘어서는 경우 0을 반환, n인 경우 1을 반환해줌
- count라는 변수에 반복으로 실행되는 재귀함수의 결과값을 더하도록 처리해주고, 반복문 실행이 모두 끝나면 count를 반환하도록 해 다음 함수 스택에서 이어가도록 함
- 재귀함수로 쌓인 스택이 전부 실행되고 나면, 결과값으로 반환되는 count엔 모든 n이 되는 경우에 수가 담기게 됨