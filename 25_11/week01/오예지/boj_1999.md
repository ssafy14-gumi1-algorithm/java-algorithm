# 요구사항 분석
NxN 행렬이 있음.\
주어진 행렬의 BxB 크기의 부분행렬의 최대값과 최소값의 차이를 묻는 질문들에 대한 답을 출력

## 입력
첫째 줄에는 세 정수 N, B, K가 주어진다. \
다음 N개의 줄에는 행렬이 주어진다. 차례로 1행, 2행, …, N행이 된다. \
각 줄에는 N개의 정수가 주어지며, 이는 차례로 1열의 성분, 2열의 성분, …, N열의 성분이 된다.\
다음 K개의 줄에는 질문들이 주어진다.\
각 질문들은 두 정수 i, j로 주어진다.\
i는 부분행렬의 가장 윗쪽의 행 번호이며, j는 부분행렬의 가장 왼쪽의 열 번호이다(1 ≤ i, j ≤ N-B+1)

## 출력(목표)
K개의 줄에, 차례로 각 질문의 답변(부분행렬의 최댓값과 최솟값의 차이값)을 출력한다.

# 왜 코드를 그렇게 짰는지
- 질문이 최대 100,000개여서 질문을 받을 때마다 해당 부분 행렬의 최댓값과 최솟값을 찾는 것은 비효율적이라고 생각했음
- 해당 i, j에 해당하는 최댓값과 최솟값의 차를 미리 배열에 저장해두고, 질문이 나왔을 때 바로 사용

# 핵심 로직
- 배열을 미리 저장해 둠
```declarative
public static void partArr() {
    for(int i=0; i<N-B+1; i++) {
        for(int j=0; j<N-B+1; j++) {
            int maxV = num[i][j];
            int minV = num[i][j];
            for(int k=i; k<i+B; k++) {
                for(int l=j; l<j+B; l++) {
                    maxV = Math.max(maxV, num[k][l]);
                    minV = Math.min(minV, num[k][l]);
                }
            }
            resultArr[i][j] = maxV - minV;
        }
    }
}
```

- 질문이 들어왔을 때 바로 사용
```declarative
for(int i=0; i<K; i++) {
    st = new StringTokenizer(br.readLine());
    int ni = Integer.parseInt(st.nextToken());
    int nj = Integer.parseInt(st.nextToken());

    sb.append(resultArr[ni-1][nj-1]).append("\n");
}
```
