# 요구사항 분석
미친 아두이노

- 요즘 종수는 아두이노를 이용해 "Robots"이라는 게임을 만들었다.
- 종수는 아두이노 한대를 조정하며, 미친 아두이노를 피해다녀야 한다.
- 미친 아두이노는 종수의 아두이노를 향해 점점 다가온다.
- 하지만, 미친 아두이노의 움직임은 예측할 수 있다.

- 게임은 R×C크기의 보드 위에서 이루어지며, 아래와 같은 5가지 과정이 반복된다.

- 먼저, 종수가 아두이노를 8가지 방향(수직,수평,대각선)으로 이동시키거나, 그 위치에 그대로 놔둔다.
- 종수의 아두이노가 미친 아두이노가 있는 칸으로 이동한 경우에는 게임이 끝나게 되며, 종수는 게임을 지게 된다.
- 미친 아두이노는 8가지 방향 중에서 종수의 아두이노와 가장 가까워 지는 방향으로 한 칸 이동한다. 즉, 종수의 위치를 (r1,s1), 미친 아두이노의 위치를 (r2, s2)라고 했을 때, |r1-r2| + |s1-s2|가 가장 작아지는 방향으로 이동한다.
- 미친 아두이노가 종수의 아두이노가 있는 칸으로 이동한 경우에는 게임이 끝나게 되고, 종수는 게임을 지게 된다.
- 2개 또는 그 이상의 미친 아두이노가 같은 칸에 있는 경우에는 큰 폭발이 일어나고, 그 칸에 있는 아두이노는 모두 파괴된다.

- 종수의 시작 위치, 미친 아두이노의 위치, 종수가 움직이려고 하는 방향이 주어진다.
- 입력으로 주어진 방향대로 종수가 움직였을 때, 보드의 상태를 구하는 프로그램을 작성하시오.
- 중간에 게임에서 지게된 경우에는 몇 번째 움직임에서 죽는지를 구한다.

## 입력
- 첫째 줄에 보드의 크기 R과 C가 주어진다. (1 ≤ R, C ≤ 100)
- 다음 R개 줄에는 C개의 문자가 주어지며, 보드의 상태이다.
- '.'는 빈 칸, 'R'은 미친 아두이노, 'I'는 종수의 위치를 나타낸다.
- 마지막 줄에는 길이가 100을 넘지않는 문자열이 주어지며, 종수가 움직이려고 하는 방향이다.
- 5는 그 자리에 그대로 있는 것을 나타내고, 나머지는 아래와 같은 방향을 나타낸다.
- 보드를 벗어나는 입력은 주어지지 않는다.

## 출력(목표)
- 중간에 게임이 끝나는 경우에는 "kraj X"를 출력한다.
- X는 종수가 게임이 끝나기 전 까지 이동한 횟수이다.
- 그 외의 경우에는 보드의 상태를 입력과 같은 형식으로 출력한다.

# 왜 코드를 그렇게 짰는지
- 미친 아두이노들이 서로 겹치는 경우 터지는 경우가 좀 성가심
- 겹치는 블럭이 2개, 3개, 여러개 겹쳐서 한 번에 터지는 경우를 고려하려면 아두이노들을 전부 이동시킨 다음에 처리해야함
- 그래서 아두이노의 이동을 새로운 배열에 담아두고, 터지는 경우, 종수가 잡히는 경우들을 처리한 후에 배열을 덮어씌워줬다.

# 핵심 로직
## 1. 종수가 아두이노로 이동하는 경우 flag로 게임종료
- 미친 아두이노의 이동은 예측할 수 없어서 종수가 이동할때 미친 아두이노를 만나면 바로 게임을 종료해야 함
``` java
// 종수 아두이노 이동
gx += dx[mv - 1];
gy += dy[mv - 1];

// 종수 아두이노가 미친 아두이노를 만나면 바로 게임 종료
if (game_arr[gy][gx] == 'R') {
    catchFlag = true;
    break;
}
```

## 2. 이동 1번마다 업데이트한 배열 덮어씌우기
- 아두이노들의 이동을 동시에 처리한 후에 아두이노 폭발여부, 게임종료 여부를 판단해야 하기 때문에 반복문마다 새로운 배열 생성
- 새로운 배열에 아두이노들의 이동 경우를 전부 업데이트 하고, 다시 게임판 배열이랑 아두이노들의 위치 정보를 재할당시킴

```java
// 업데이트할 게임판, 미친 아두이노 좌표
char[][] update_game = new char[N][M];
for (int i = 0; i < N; i++) {
    Arrays.fill(update_game[i], '.');
}
List<int[]> update_m_dir = new ArrayList<>();
```
```java
// 미친 아두이노 이동
    for (int idx = 0; idx < m_dir.size(); idx++) {
        int[] cur = m_dir.get(idx);
        int x = cur[0];
        int y = cur[1];

        // 종수 아두이노랑 최소 간격(100정도면 될 줄 알았는데 100보다 더 긴 경우가 있었나봄 이거땜에 틀렸음)
        int min_len = Integer.MAX_VALUE;
        int mx = x;
        int my = y;

        for (int i = 0; i < 9; i++) {
            int nx = x + dx[i];
            int ny = y + dy[i];
            int g_len = Math.abs(gx - nx) + Math.abs(gy - ny);
            if (g_len < min_len) {
                mx = nx;
                my = ny;
                min_len = g_len;
            }
        }

        // min_len이 0이면 종수 잡은거니 바로 종료
        if (min_len == 0) {
            catchFlag = true;
            break;
        }

        // 미친 아두이노 이동시키기(겹치면 폭파)
        if (update_game[my][mx] == 'R') {
            break_dir.add(new int[]{mx, my});
        } else {
            update_game[my][mx] = 'R';
        }
    }

    // 종수 잡았으면 종료
    if (catchFlag) break;

    // 폭파할 블록있으면 폭파
    for (int[] p : break_dir) {
        int bx = p[0], by = p[1];
        update_game[by][bx] = '.';
    }

    // 미친 아두이노 좌표 업데이트
    for (int y = 0; y < N; y++) {
        for (int x = 0; x < M; x++) {
            if (update_game[y][x] == 'R') {
                update_m_dir.add(new int[]{x, y});
            }
        }
    }

    // 업데이트
    game_arr = update_game;
    m_dir = update_m_dir;
}
```



