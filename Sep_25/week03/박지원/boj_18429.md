# 요구사항 분석
3대 중량, 매일 k만큼 감소\
ex) 3대 500, k=4라면 3일 후 3대488됨(500-4*3)

하루에 1개씩의 키트를 사용, N일 동안 키트 하나씩만 사용 가능

항상 중량이 500 이상으로  유지가 되도록 N일간의 운동 플랜(==1일차부터 N일차까지의 모든 기간동안, 어떤 시점에서라도 중량이 500보다 작아지지 않도록)

## 입력
첫째 줄 N개의 운동 키트, 중량 K만큼 감소(1 ≤ N ≤ 8, 1 ≤ K ≤ 50)\
둘째 줄 각 운동 키트의 중량 증가량 A(1 ≤ A ≤ 50)

## 출력(목표)
N일 동안 N개의 운동 키트를 사용하는 모든 경우 중에서, 운동 기간동안 항상 중량이 500 이상이 되도록 하는 경우의 수를 출력

# 왜 코드를 그렇게 짰는지
뭔가 하루 1개씩 키트 사용 N일 동안 키트 하나씩만 사용 가능 → 이 부분을 봤을 때 DP(0-1 knapsack)인가? 생각했다

그런데 항상 중량이 500kg이상으로 유지되어야 한다는 조건이 있어서, DP로 해당 조건을 충족시킬 수 없다고 생각했다.

DP로 풀 수 있는 문제는 보통i번째, i일까지 고려했을 때, j번째까지 운동을 했을 때 최대 중량 이런 식으로 나와야 함

이 문제는 매일 중량 500이상으로 유지하라고 했으니까 백트래킹+가지치기(하루라도 중량이 500 미만이 되는 경우 return)\
\+ 경우의수를 구해야 하는 문제니까... DP로는 풀 수 없음

순서가 있음 1, 2, 3 순서로 했을 때, 조건 만족 x이지만, 2, 3, 1 순서로 했을 때 조건 만족

n일 동안 n개의 운동기구를 사용해야 하므로 순열

# 핵심 로직
문제의 예시를 봤을 때, 첫날의 중량은 500

k만큼 감소하고, 선택한 기구의 중량만큼 증량한 것이 그날의 중량 `currWeight` → 이게 500 미만인 날이 되게 하는 기구는 선택하지 않도록 함

```java
private static void backtracking(int idx, int weight, boolean[] visited) {
    // 종료 조건: 끝까지 왔으면
    if(idx==n){
        if(weight<500) return; // 이건 사실 없어도 됨
        answer++;
        return;
    }

    for (int i = 0; i < n; i++) {
        if(visited[i]) continue;

        // 해당 기구를 선택했을 때 중량이 500을 넘지 못하면 선택하지 않음
        int currWeight = weight-k+machines[i];
        if(currWeight<500) continue;

        visited[i] = true;
        backtracking(idx+1, currWeight, visited);
        visited[i] = false;
    }
}
```
# 제출
![boj_18429_1.png](Attached/boj_18429_1.png)
