# 요구사항 분석
치즈

- 아래 <그림 1>과 같이 정사각형 칸들로 이루어진 사각형 모양의 판이 있고,
- 그 위에 얇은 치즈(회색으로 표시된 부분)가 놓여 있다.
- 판의 가장자리(<그림 1>에서 네모 칸에 X친 부분)에는 치즈가 놓여 있지 않으며 치즈에는 하나 이상의 구멍이 있을 수 있다.

- 이 치즈를 공기 중에 놓으면 녹게 되는데 공기와 접촉된 칸은 한 시간이 지나면 녹아 없어진다.
- 치즈의 구멍 속에는 공기가 없지만 구멍을 둘러싼 치즈가 녹아서 구멍이 열리면 구멍 속으로 공기가 들어가게 된다.
- <그림 1>의 경우, 치즈의 구멍을 둘러싼 치즈는 녹지 않고 ‘c’로 표시된 부분만 한 시간 후에 녹아 없어져서 <그림 2>와 같이 된다.

- 다시 한 시간 후에는 <그림 2>에서 ‘c’로 표시된 부분이 녹아 없어져서 <그림 3>과 같이 된다.

- <그림 3>은 원래 치즈의 두 시간 후 모양을 나타내고 있으며, 남은 조각들은 한 시간이 더 지나면 모두 녹아 없어진다.
- 그러므로 처음 치즈가 모두 녹아 없어지는 데는 세 시간이 걸린다.
- <그림 3>과 같이 치즈가 녹는 과정에서 여러 조각으로 나누어 질 수도 있다.

- 입력으로 사각형 모양의 판의 크기와 한 조각의 치즈가 판 위에 주어졌을 때,
- 공기 중에서 치즈가 모두 녹아 없어지는 데 걸리는 시간과
- 모두 녹기 한 시간 전에 남아있는 치즈조각이 놓여 있는 칸의 개수를 구하는 프로그램을 작성하시오.


## 입력
- 첫째 줄에는 사각형 모양 판의 세로와 가로의 길이가 양의 정수로 주어진다. 
- 세로와 가로의 길이는 최대 100이다. 
- 판의 각 가로줄의 모양이 윗 줄부터 차례로 둘째 줄부터 마지막 줄까지 주어진다. 
- 치즈가 없는 칸은 0, 치즈가 있는 칸은 1로 주어지며 각 숫자 사이에는 빈칸이 하나씩 있다.

## 출력(목표)
- 첫째 줄에는 치즈가 모두 녹아서 없어지는 데 걸리는 시간을 출력하고, 
- 둘째 줄에는 모두 녹기 한 시간 전에 남아있는 치즈조각이 놓여 있는 칸의 개수를 출력한다.

# 왜 코드를 그렇게 짰는지
- 외곽의 치즈만 시간이 지나며 녹는다(외부 공기와 접촉한 치즈).
- 매 시간 다음을 반복한다:
- 1) (0,0) 외부 공기에서 시작해 BFS로 빈 칸(0)만 퍼지며 탐색한다.
- 2) 탐색 중 인접한 칸이 치즈(1)면, 그 좌표를 “이번 시간에 녹일 후보”에 수집한다(이 칸은 큐에 넣지 않음).
- 3) BFS 종료 후 후보들을 모두 0으로 바꾸어 녹인다.
- 4) 녹인 개수를 기록하고, 더 이상 녹일 치즈가 없으면 종료.
- 시간복잡도는 각 시간당 O(N*M), 전체도 O(시간 * N*M)로 N,M ≤ 100에서 충분.

# 핵심 로직
## 치즈 외곽만 녹이는 BFS
- visited가 체크되지 않은 가장 끝쪽의 빈공간(0)을 시작점으로 하는 BFS를 실행한다.
- BFS 도중, 치즈(1)을 만나게 되면, 그 방향으로는 접근하지 않고, 따로 배열에 좌표만 담는다.
- 1번 BFS를 돌리고 나면, 치즈의 외곽들은 전부 좌표가 기록되고, 바깥의 빈공간들은 전부 visited 체크가 된다.
- 좌표에 기록된 치즈들을 전부 0으로 바꿔주면 BFS가 1번 종료된다.
- 이제 다음 BFS의 시작 큐에 치즈의 외곽 좌표들을 전부 담아 다시 실행한다.
- 치즈가 다 사라질 때 까지 반복하면 결과를 구할 수 있음

```java
// 치즈 녹이기 1 싸이클: 외부 공기(0,0)에서 BFS, 외부 공기와 맞닿은 치즈를 수집 후 일괄 제거
static int meltOnce() {
    boolean[][] visited = new boolean[N][M];
    Deque<int[]> q = new ArrayDeque<>();
    q.addLast(new int[]{0, 0});
    visited[0][0] = true;

    List<int[]> toMelt = new ArrayList<>();

    while (!q.isEmpty()) {
        int[] cur = q.pollFirst();
        int x = cur[0], y = cur[1];

        for (int d = 0; d < 4; d++) {
            int nx = x + dx[d];
            int ny = y + dy[d];
            if (nx < 0 || ny < 0 || nx >= M || ny >= N) continue;
            if (visited[ny][nx]) continue;

            if (board[ny][nx] == 1) {
                // 외부 공기와 접한 치즈 → 이번 시간에 녹인다
                visited[ny][nx] = true;          // 중복 수집 방지
                toMelt.add(new int[]{nx, ny});
            } else { // 빈 칸(외부 공기) → 계속 확장
                visited[ny][nx] = true;
                q.addLast(new int[]{nx, ny});
            }
        }
    }

    // 수집된 치즈를 모두 녹임
    for (int[] p : toMelt) {
        int x = p[0], y = p[1];
        board[y][x] = 0;
    }
    return toMelt.size();
}
```
