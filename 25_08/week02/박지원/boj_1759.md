# 요구사항 분석
암호는 서로 다른 L개의 알파벳 소문자들로 구성되며 최소 한 개의 모음(a, e, i, o, u)과 최소 두 개의 자음으로 구성\
암호를 이루는 알파벳이 암호에서 증가하는 순서로 배열되었을 것(abc는 가능성이 있는 암호이지만 bac는 그렇지 않다.)\
조교들이 암호로 사용했을 법한 문자의 종류는 C가지. C개의 문자들이 모두 주어졌을 때, 가능성 있는 암호들을 모두 구하는 프로그램을 작성
## 입력
첫째 줄에 두 정수 L, C (3 ≤ L ≤ C ≤ 15)\
다음 줄에는 C개의 문자들이 공백으로 구분되어 주어진다(주어지는 문자들은 알파벳 소문자이며, 중복되는 것은 없다.)
## 출력(목표)
각 줄에 하나씩, 사전식으로 가능성 있는 암호를 모두 출력
# 왜 코드를 그렇게 짰는지
L개의 알파벳 소문자에서 C개의 문자를 뽑는 문제.\
여기까지만 주어졌으면 순서가 중요하므로 순열 문제가 된다. 하지만 암호를 이루는 알파벳은 항상 증가하는 순서로 배열된다는 조건이 붙었기 때문에, abc는 가능, cba는 불가능해졌다.\
따라서 이 문제는 조합 문제가 된다(a, b, c를 이용해 만들 수 있는 암호가 abc 하나 뿐. a를 처음에 뽑으면 다음에는 a보다 큰 알파벳만 나올 수 있음.)\
`Arrays.sort(alpha);` 암호가 정렬된 순서로 나오는 조합이어야 하므로 입력 배열을 정렬해주고, 조합을 구하기 시작\
`makePassword()`함수에서 재귀호출을 통해 조합을 만들고, r개를 선택했으면 자음과 모음의 갯수를 세서, 자음2개 이상 && 모음 1개 이상으로 이루어졌는지 검사\
검사를 통과하면 가능성이 있는 암호이므로 출력해준다.

# 핵심 로직
```java
/**
 *
 * @param start start인덱스부터 뽑기 시작
 * @param cnt   지금까지 cnt 개 뽑음
 */
public static void makePassword(int start, int cnt) {
    // 종료조건: r개 뽑았으면 종료
    if (cnt == r) {
        // System.out.println(Arrays.toString(selected));
        // 암호는 서로 다른 L개의 알파벳 소문자들로 구성되며 최소 한 개의 모음(a, e, i, o, u)과 최소 두 개의 자음으로 구성
        int consonant = 0; // 자음의 수
        int vowel = 0; // 모음의 수
        for (int i = 0; i < r; i++) {
            if (isVowel(selected[i])) vowel++;
            else consonant++;
        }
        // 가능성 있는 암호일 경우
        if (consonant >= 2 && vowel >= 1) {
            for (int i = 0; i < r; i++) {
                System.out.print(selected[i]);
            }
            System.out.println();
        }
        return;
    }

    // 재귀 호출
    for (int i = start; i < n; i++) {
        selected[cnt] = alpha[i]; // cnt 번째 수로 alpha[i]를 뽑음
        makePassword(i + 1, cnt + 1);
    }
}
```