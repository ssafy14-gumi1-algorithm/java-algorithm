### 1\. 요구사항 분석

* **입력**:
    * `T`: 테스트 케이스의 개수 (1 \<= T \<= 50)
    * `N`: 트리를 구성하는 노드의 개수 (2 \<= N \<= 10,000)
* **출력**:
    * 각 테스트 케이스에 대해 `node1`과 `node2`의 \*\*가장 가까운 공통 조상(Lowest Common Ancestor)\*\*을 출력한다.
* **문제 목표**:
    * 주어진 트리에서 두 노드의 가장 가까운 공통 조상을 찾는 알고리즘을 구현
* **변수의 범위**:
    * `N`이 최대 10,000
* **시간 복잡도**:
    * while을 통해 리스트에 조상들을 저장하는 연산 : 최대 N
    * 이게 두번 : 최대 2N
    * 리스트 두개로 이중 포문을 돌면서 공통조상을 찾는 연산 : 최대 N^2
    * 총 O(N^2 + 2N) : 코테에서는 최고차항 생략하지 말기
    * 총 10020000 번의 연산을 1초안에 해야함. 자바는 1초에 5000만번 정도, 불가능, 근데 돌아간다? 왜지?

### 2\. 왜 코드를 그렇게 작성했는지

- 공통조상을 찾는 문제임
- 근데 이진트리가 아니라서 수업시간에 배운 재귀순회를 사용할 수 없음
- 그래서 각 노드의 부모를 전부 배열에 저장한 다음 완전탐색을 통해 같은 값을 찾도록 만들었음

### 3\. 본인이 분리한 함수 설명

* `solve(int node1, int node2)`: 이 함수는 두 노드 `node1`과 `node2`를 인자로 받아, 그들의 가장 가까운 공통 조상을 찾아 반환하는 역할을 한다.



### 4\. 배운점/개선하고 싶은 점

* **배운점**:
    * 이진트리순회를 쓰는게 아니라면 그냥 parents배열로 간단하게 풀 수 있는 문제이다
    * 아마 같은 부모를 찾기만 하면 되는 거라서 그런듯
* **개선하고 싶은 점**:
    * 현재 코드는 \*\*시간 복잡도가 O(N^2)\*\*에 가깝다. N이 커질 경우 시간 초과가 발생할 수 있다
    * 아마 문제의 테케는 N이 10000까지 가는 경우가 없어서 풀린듯
    * **두 노드의 조상들을 각각 `HashSet`에 저장**하여 공통 조상을 찾는 방법도 이중 루프보다 효율적입니다. -> 제미나이 답변
    * `HashSet`의 `contains` 연산은 평균 O(1)이므로, 전체 시간 복잡도는 O(N)이 됩니다.
      ```java
      // 개선된 solve 함수 (HashSet 사용)
      static int solveOptimized(int node1, int node2) {
          Set<Integer> ancestors1 = new HashSet<>();
          int current = node1;
          while (current != 0) {
              ancestors1.add(current);
              current = parents[current];
          }

          current = node2;
          while (current != 0) {
              if (ancestors1.contains(current)) {
                  return current;
              }
              current = parents[current];
          }
          return 0;
      }
      ```