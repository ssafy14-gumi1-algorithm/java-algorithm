## sentence advise

The prompt is written entirely in Korean with the exception of the provided Java code and standard English placeholders like `TODO`. Since the request is to write the solution file in the same Korean format as before, and there's no English sentence provided for advice, the 'sentence advise' section will be skipped this time as it's not applicable.

---

## BOJ 14500 테트로미노

### 요구사항 분석

- **입력**
    - 첫째 줄에 종이의 세로 크기 $\mathbf{N}$과 가로 크기 $\mathbf{M}$이 주어진다 ($\mathbf{4} \le \mathbf{N}, \mathbf{M} \le \mathbf{500}$).
    - 둘째 줄부터 $\mathbf{N}$개의 줄에 종이에 쓰여 있는 수가 주어진다 ($1 \le \text{수} \le 1,000$).

- **출력**
    - 테트로미노가 놓인 칸에 쓰여 있는 수들의 합의 **최댓값**을 출력한다.

- **문제 목표**
    - $\mathbf{N} \times \mathbf{M}$ 크기의 종이 위에 4개의 칸을 차지하는 5가지 모양의 테트로미노 중 하나를 놓는다.
    - 테트로미노는 **회전이나 대칭**이 가능하며, 모든 가능한 모양을 고려해야 한다.
    - 놓인 칸의 수의 합이 최대가 되도록 테트로미노의 위치와 모양을 결정해야 한다.

- **시간복잡도**
    - $\mathbf{N, M}$이 최대 500이다.
    - 총 **19가지**의 회전/대칭된 테트로미노 모양을 모두 정의하고, 각 모양에 대해 종이 위의 모든 위치에 놓아보는 **완전 탐색**을 시도한다.
    - 시간복잡도는 $\mathbf{O(R \times C \times \text{테트로미노 모양의 수}})$로, $500 \times 500 \times 19 \approx 475$만 번의 연산으로 충분히 해결 가능하다.

---

### 풀이 및 작성 이유

- 이 문제는 가능한 모든 경우의 수를 탐색하여 최댓값을 찾는 **완전 탐색 (Brute Force)** 문제다.
- 테트로미노의 모양은 총 5가지지만, **회전과 대칭**을 고려하면 총 **19가지**의 유효한 모양 (중복 제외)이 존재한다.
    - '바' 모양 (I): 2가지 (가로, 세로)
    - '정사각형' 모양 (O): 1가지
    - '니은' 모양 (J, L): 8가지 (4방향 회전 $\times$ 2가지 대칭)
    - '번개' 모양 (S, Z): 4가지 (2방향 회전 $\times$ 2가지 대칭)
    - 'ㅗ' 모양 (T): 4가지 (4방향 회전)

- **풀이 아이디어**
    1. **모든 테트로미노 모양 정의**: 코드를 통해 $19$가지 모양을 2차원 배열 형태로 미리 정의한다.
    2. **완전 탐색**: 정의된 $19$가지 모양 각각에 대해, 종이 위의 모든 가능한 시작 위치 $(\mathbf{i}, \mathbf{j})$에 테트로미노를 놓아본다.
    3. **합 계산**: 테트로미노 모양을 나타내는 2차원 배열과 종이 배열 $\mathbf{arr}$를 겹쳐 보면서, 테트로미노의 1에 해당하는 위치의 값들을 모두 더해 합을 계산한다.
    4. **최댓값 갱신**: 계산된 합을 전역 변수 $\mathbf{result}$와 비교하여 최댓값을 갱신한다.

- 코드를 보면 이 아이디어를 그대로 구현했다. 모든 모양을 미리 **하드 코딩**하여 정의한 후, 이 모양들을 $\mathbf{N} \times \mathbf{M}$ 격자 위에서 슬라이딩하며 합을 구하는 방식이다. 이 방식은 구현이 간단하고, $\mathbf{N, M}$의 제약이 작으므로 효율적이다.

---

### 함수 설명

- **`main(String[] args)`**
    - $\mathbf{N}, \mathbf{M}$과 종이 배열 $\mathbf{arr}$를 입력받는다.
    - **`tetrominos` 배열 순회**: 미리 정의된 19가지 테트로미노 모양을 순서대로 하나씩 가져온다.
    - **슬라이딩 윈도우 탐색**:
        - 현재 테트로미노의 크기 $\mathbf{n}$ (행), $\mathbf{m}$ (열)을 구한다.
        - 종이 위에서 테트로미노를 놓을 수 있는 모든 시작 위치 $(\mathbf{i}, \mathbf{j})$를 순회한다. $\mathbf{i}$는 $\mathbf{N}-\mathbf{n}+1$까지, $\mathbf{j}$는 $\mathbf{M}-\mathbf{m}+1$까지 순회한다.
    - **합 계산**: 중첩된 반복문으로 현재 위치에 놓인 테트로미노의 합 $\mathbf{sum}$을 계산한다. `tetromino[k][l] == 1`일 때만 $\mathbf{arr[i+k][j+l]}$ 값을 $\mathbf{sum}$에 더한다.
    - **최댓값 갱신**: $\mathbf{result = Math.max(result, sum)}$을 통해 최댓값을 갱신한다.
    - 최종 $\mathbf{result}$를 출력한다.

---

### 배운 점/개선점

- **완전 탐색의 효율성**: 문제의 제약 조건 ($\mathbf{N, M} \le 500$)을 보고, **모든 경우를 탐색하는** 완전 탐색으로 문제를 해결할 수 있음을 파악하는 훈련이 되었다.
- **테트로미노 모양의 분류**: 5가지 기본 테트로미노 모양에 대한 **회전 및 대칭** 경우의 수를 정확히 정의하고 코드로 옮기는 과정이 중요함을 깨달았다. 빠짐없이 $19$가지 모양을 정의해야 정답을 얻을 수 있다.
- **개선점 (DFS/BFS를 이용한 방법)**:
    - 현재 풀이 방식은 모든 모양을 하드 코딩해야 하는 단점이 있다.
    - **다른 방법**으로는, 4칸을 연결하는 모든 경우를 **DFS**로 탐색하고, 탐색 과정에서 $\mathbf{4}$칸을 연결한 후 합을 계산하는 방법이 있다. 이 경우 'ㅗ' 모양만 예외적으로 처리해야 한다.
    - $\mathbf{N, M}$이 더 작다면 이 방법도 유용하지만, 현재 문제에서는 **19가지 모양을 정의하고 슬라이딩하는** 방식이 가장 빠르고 실수할 여지가 적어 보인다.
```