## BOJ 1189 돌아가기

### 요구사항 분석

- **입력**
    - 첫째 줄에 $\mathbf{R}$, $\mathbf{C}$, $\mathbf{K}$가 주어진다 ($1 \le \mathbf{R}, \mathbf{C} \le 5$, $1 \le \mathbf{K} \le \mathbf{R} \times \mathbf{C}$).
        - $\mathbf{R}$: 행의 수, $\mathbf{C}$: 열의 수, $\mathbf{K}$: 이동해야 하는 **정확한 거리**.
    - 다음 $\mathbf{R}$개의 줄에는 $\mathbf{C}$개의 문자가 주어진다.
        - '.': 지나갈 수 있는 칸, 'T': 가지 못하는 벽.
    - 시작점은 $(\mathbf{R}-1, 0)$, 도착점은 $(0, \mathbf{C}-1)$이다.

- **출력**
    - 집까지 **정확히 $\mathbf{K}$ 거리**로 가는 경로의 개수를 출력한다.

- **문제 목표**
    - 시작점 $(\mathbf{R}-1, 0)$에서 도착점 $(0, \mathbf{C}-1)$까지 **정확히 $\mathbf{K}$ 칸**을 이동하는 모든 경로의 수를 구해야 한다.
    - 이동은 상하좌우 인접한 칸으로만 가능하며, **한 번 방문한 칸은 다시 방문할 수 없고**, 'T'는 갈 수 없다.

- **시간복잡도**
    - $\mathbf{R}, \mathbf{C}$가 최대 5로 매우 작기 때문에 ($R \times C \le 25$), 모든 가능한 경로를 탐색하는 **백트래킹(DFS)**으로 충분히 해결 가능하다.

---

### 풀이 및 작성 이유

- 특정 길이의 경로 수를 세는 문제임, 최단경로를 보장할 필요가 없으므로 dfs사용
- 또한 하나의 경로를 끝까지 간 후 다른 경로를 탐색할 때는 이미 갔던 경로로도 가야 하므로
- 해당 경로를 탐색한 후에는 방문체크를 해제함
---

### 함수 설명

- **`main(String[] args)`**
    - 입력 $\mathbf{R, C, K}$ 및 격자 $\mathbf{arr}$를 읽어들이고, $\mathbf{visited}$ 배열을 `-1`로 초기화한다.
    - 시작점 $\mathbf{(R-1, 0)}$을 **방문 처리** $\mathbf{(visited[R-1][0] = 1)}$하고 $\mathbf{dist=1}$로 **DFS**를 시작한다.
    - 탐색 완료 후 최종 경로의 개수 $\mathbf{result}$를 출력한다.

- **`dfs(int cur_i, int cur_j, int dist)`**
    - **`cur_i, cur_j`**: 현재 위치의 행과 열이다.
    - **`dist`**: 현재까지 이동한 총 거리다.
    - **종료 조건**: `dist == K`이면 도착점 $(0, \mathbf{C}-1)$과 일치하는지 검사하여 $\mathbf{result}$를 갱신한다.
    - **탐색**: 상하좌우 $(\mathbf{di}, \mathbf{dj})$ 네 방향을 순회하며 다음 위치 $(\mathbf{ni}, \mathbf{nj})$를 계산한다.
    - **이동 조건**: $(\mathbf{ni}, \mathbf{nj})$가 유효한 범위 내이고, 미방문 상태이며, 'T'가 아니면 이동을 진행한다.
    - **백트래킹 과정**:
        1. **진입 전**: `visited[ni][nj] = 1;` (방문)
        2. **재귀 호출**: `dfs(ni, nj, dist + 1);`
        3. **복귀 후**: `visited[ni][nj] = -1;` (방문 해제, 백트래킹)

---

### 배운 점/개선점

- **정확한 거리 조건 처리**: BFS로는 최단 거리만 구할 수 있지만, DFS를 통해 모든 경로를 탐색하면서 **정확히 $\mathbf{K}$번** 이동했을 때의 위치를 확인하는 방식으로 조건을 만족시킬 수 있음을 확인했다.
- **백트래킹의 필수성**: 한 칸을 지나고 나면 **반드시 방문 상태를 해제**해야만, 이후 다른 경로 탐색 시 해당 칸을 다시 사용할 수 있다는 **백트래킹의 핵심 원리**를 구현하는 데 집중했다.
- $\mathbf{R, C}$의 크기가 작을 때는 DFS/백트래킹이 효과적인 풀이 방법임을 익힌다.