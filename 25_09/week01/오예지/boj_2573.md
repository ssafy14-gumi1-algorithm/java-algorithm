# 요구사항 분석
1년동안 주변에 있는 0의 개수만큼 녹음
    - 녹은 빙산의 높이 -> 델타(네방향탐색)로 주변의 0의 개수를 구하기
    - 녹을 빙산의 높이를 찾아서 배열에 넣기
    - 이유는? -> 한번에 녹여야 하니까
동서남북 방향으로 붙어있는 칸 -> 연결되어있다고 생각
    - 덩어리 -> BFS 사용하면 되지 않을까

## 입력
첫 줄에는 이차원 배열의 행의 개수와 열의 개수를 나타내는 두 정수 N과 M이 한 개의 빈칸을 사이에 두고 주어진다.\
N과 M은 3 이상 300 이하이다.\
그 다음 N개의 줄에는 각 줄마다 배열의 각 행을 나타내는 M개의 정수가 한 개의 빈 칸을 사이에 두고 주어진다.\
각 칸에 들어가는 값은 0 이상 10 이하이다.\
배열에서 빙산이 차지하는 칸의 개수, 즉, 1 이상의 정수가 들어가는 칸의 개수는 10,000 개 이하이다.\
배열의 첫 번째 행과 열, 마지막 행과 열에는 항상 0으로 채워진다.

## 출력(목표)
첫 줄에 빙산이 분리되는 최초의 시간(년)을 출력한다.\
만일 빙산이 다 녹을 때까지 분리되지 않으면 0을 출력한다.

# 왜 코드를 그렇게 짰는지
1. 빙하의 상하좌우의 0의 개수를 구해야해서 델타 사용
2. 빙하를 한번에 녹여야하니까 녹을 높이를 배열에 저장해서 한번에 녹여줌
3. 덩어리의 개수를 구해야 하니까 BFS 사용

# 핵심 로직

```declarative
static int checkYear() {
        int cntYear = 0;

        while (!isZero()) {
            cntYear++;
            melting();

            int cnt = 0;
            visited = new int[N][M];

            while (true){
                int[] start = findStart();
                int si = start[0];
                int sj = start[1];

                if (si == -1) break;

                bfs(si, sj);
                cnt ++;

                if (cnt >= 2){
                    return cntYear;
                }
            }
        }
        return 0;
    }
```

# 제출
백준 제출 사진 