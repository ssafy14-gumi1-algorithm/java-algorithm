# 요구사항 분석
숨바꼭질

- 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고
- 동생은 점 K(0 ≤ K ≤ 100,000)에 있다.
- 수빈이는 걷거나 순간이동을 할 수 있다
- 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다.
- 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.

- 수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.

## 입력
- 첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.

## 출력(목표)
- 수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.

# 왜 코드를 그렇게 작성했는지
- 수빈이가 가장 빠르게 동생에게 도착하려면 한 번에 동생에게 도착하는게 젤 빠름
- 따라서 적절하게 순간이동할 지점을 잡고 순간이동을 최대한 활용해서 가깝게 접근하는 케이스를 구해야 함
- 그러기 위해선 완전 탐색을 활용해 모든 이동 경로를 조사하면서 가장 최단시간으로 동생에게 도착하는 케이스를 찾아야 함
- BFS를 활용해야 함
- 뒤로 이동하는 케이스도 있어 무한으로 뒤로가는 경우가 발생하니 visited배열을 만들어 이미 갔던 지역은 다시 못가도록 막아야 함


# 핵심 로직
## 1. BFS로 모든 이동 케이스 구하기
- 문제에선 가장 최소한의 시간으로 동생에게 도착하는 케이스를 구해야 함(최단경로 구하는 문제)
- 뒤로 가기, 앞으로 가기를 사용해서 순간이동을 최적으로 사용할 수 있는 방법을 찾아야 하는데 이걸 직접 구현하는 알고리즘을 짤 수 있나?
- BFS로 모든 케이스를 레벨별로 실행해서 가장 먼저 동생에게 도착하는 케이스를 만나면 BFS를 종료하고 그 시간을 출력하면 문제 해결
```java
static int bfs(int start, int target) {
    Queue<int[]> queue = new ArrayDeque<>();
    queue.add(new int[]{start, 0});
    visited[start] = true;

    while (!queue.isEmpty()) {
        int[] cur = queue.poll();
        // 현재 위치
        int pos = cur[0];
        // 걸린 시간
        int time = cur[1];

        // 동생 위치 도착 → 최단 시간 반환
        if (pos == target) {
            return time;
        }

        // 다음 이동 후보들
        int[] nextPos = {pos - 1, pos + 1, pos * 2};
        for (int np : nextPos) {
            // 좌표를 벗어나지 않고, 다음 지역이 방문 안한 지역이면 이동
            if (np >= 0 && np <= MAX && !visited[np]) {
                // 방문 지역 체크
                visited[np] = true;
                queue.add(new int[]{np, time + 1});
            }
        }
    }
    return -1; // 도달 불가한 경우 (문제 조건상 발생하지 않음)
}
```

