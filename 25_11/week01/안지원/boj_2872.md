# 요구사항 분석
- 우리집엔 도서관이 있어

- 상근이는 컴퓨터 공학의 일인자가 되기 위해 책을 매우 많이 구매했다.
- 하지만, 집에 책장이 없어서 책을 탑처럼 쌓아놓고 있다.

- 오늘은 오랜만에 상근이가 집에서 휴식을 취하는 날이다.
- 상근이는 책을 알파벳 순서대로 정렬하려고 한다.
- 사전 순으로 가장 앞서는 책은 가장 위에 놓고, 가장 뒤에 있는 책은 가장 밑에 놓아야 한다.
- 책을 정렬할 때 사용할 수 있는 방법은 책 하나를 뺀 다음, 가장 위에 놓는 것이다.

- 책은 1부터 N까지 번호가 책 이름의 사전 순으로 매겨져 있다.
- 1은 사전 순으로 가장 앞서는 책이다.
- 따라서, 위에서부터 책의 번호를 읽으면 (1, 2, ..., N)이 되어야 한다.
- 예를 들어, 책이 3권 있고 처음에 (3, 2, 1)로 쌓여있을 때, 2번 만에 사전순으로 책을 쌓을 수 있다.
- 가장 먼저, 2번 책을 뺀 다음에 가장 위에 놓는다. 그렇게 되면 (2, 3, 1)이 된다.
- 마지막으로, 1을 뺀 다음 가장 위에 놓으면 (1, 2, 3)이 된다.

- 현재 책이 어떻게 쌓여있는지가 주어졌을 때, 몇 번만에 사전 순으로 쌓을 수 있는지 구하는 프로그램을 작성하시오.
## 입력
- 첫째 줄에 책의 개수 N이 주어진다. (N ≤ 300,000)
- 다음 N개 줄에는 가장 위에 있는 책부터 아래에 있는 책까지 순서대로 주어진다.
## 출력(목표)
- 첫째 줄에 몇 번만에 책을 정렬할 수 있는지 출력한다.
# 왜 코드를 그렇게 짰는지
- 내 의식의 흐름을 봐 줘
- 책의 번호는 1 ~ N개로 중복되는 번호는 없는 것 같다.
- 뽑는 건 내 맘대로 선택해서 뽑을 수 있는 것 같다.
- 그리디 문제인가?
- N이 30만이라서 1번 순회로 끝낼 수 있어야 할 듯.
- 1 ~ N+1 만큼 순회하면서 input을 하나씩 받는다.
- 지금 받는 input이 현재 숫자보다 큰 숫자라면 결과값에 +1 하면 되지 않을까?
- 거꾸로 순회 ㄱㄱ.

- 이거 아닌 것 같음.
- 최대 30만 만큼 빈 배열을 만들고, 거기에 숫자를 넣고, 교체하고 반복해야 할 것 같음.
- 이것도 아닌 것 같은데.

- 기본값(now)을 0부터 잡아서 현재 숫자를 저장시키면서 이동한다.
- 그런데, 조건이 있음.
- 저장한 숫자가 현재 숫자보다 큰 경우, 그 차이가 2 이상이면 ans에 더해주고 다음으로 넘어간다.
- 현재 숫자보다 작은 숫자들은 그냥 패스.
# 핵심 로직
## 직접 적어보면서 패턴 찾기
- 그리디는 그냥 뇌지컬 문제라 답이 없음..
- 나 처럼 암산 안되는 수포자 바보는 직접 노트에 써가면서 패턴을 찾아봐야함
![img_2.png](img_2.png)
```java
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        // 첫째 줄: 책의 개수 N 입력
        int N = Integer.parseInt(br.readLine());

        // 결과값 변수 (몇 번 움직였는지)
        int ans = 0;
        // 현재까지 본 가장 큰 책 번호 저장 변수
        int big = 1;

        // N개의 책 번호 입력 처리
        for (int i = 0; i < N; i++) {
            int now = Integer.parseInt(br.readLine());

            // big보다 2 이상 큰 값이면
            if (now - big > 1) {
                // ans에 차이값 더해주기
                ans += now - big;
                // big값 업데이트
                big = now;
            }
            // 바로 다음 숫자거나 같은 숫자면 big 업데이트
            else if (now - big == 1 || now - big == 0) {
                big = now;
            }
        }

        // 결과 출력
        System.out.println(ans);
    }
}
```
